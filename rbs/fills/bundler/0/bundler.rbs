# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) provides a
# consistent environment for Ruby projects by tracking and installing the exact
# gems and versions that are needed.
#
# Since Ruby 2.6, [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html)
# is a part of Ruby's standard library.
#
# Bunder is used by creating *gemfiles* listing all the project dependencies and
# (optionally) their versions and then using
#
# ```ruby
# require 'bundler/setup'
# ```
#
# or
# [`Bundler.setup`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html#method-c-setup)
# to setup environment where only specified gems and their specified versions
# could be used.
#
# See [Bundler website](https://bundler.io/docs.html) for extensive
# documentation on gemfiles creation and
# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) usage.
#
# As a standard library inside project,
# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) could be used
# for introspection of loaded and required modules.
module Bundler
  def self.app_cache: (?untyped custom_path) -> untyped

  def self.app_config_path: () -> untyped

  # Returns absolute location of where binstubs are installed to.
  def self.bin_path: () -> untyped

  # Returns absolute path of where gems are installed on the filesystem.
  def self.bundle_path: () -> untyped

  def self.bundler_major_version: () -> untyped

  # @deprecated Use `unbundled\_env` instead
  def self.clean_env: () -> untyped

  def self.clean_exec: (*untyped args) -> untyped

  def self.clean_system: (*untyped args) -> untyped

  def self.clear_gemspec_cache: () -> untyped

  def self.configure: () -> untyped

  def self.configured_bundle_path: () -> untyped

  # Returns current version of Ruby
  #
  # @return [CurrentRuby] Current version of Ruby
  def self.current_ruby: () -> untyped

  def self.default_bundle_dir: () -> untyped

  def self.default_gemfile: () -> untyped

  def self.default_lockfile: () -> untyped

  def self.definition: (?(::Hash[String, Boolean | nil] | Boolean | nil) unlock) -> Bundler::Definition

  def self.environment: () -> untyped

  def self.feature_flag: () -> untyped

  def self.frozen_bundle?: () -> untyped

  def self.git_present?: () -> untyped

  def self.home: () -> untyped

  def self.install_path: () -> untyped

  def self.load: () -> untyped

  def self.load_gemspec: (untyped file, ?untyped validate) -> untyped

  def self.load_gemspec_uncached: (untyped file, ?untyped validate) -> untyped

  def self.load_marshal: (untyped data) -> untyped

  def self.local_platform: () -> untyped

  def self.locked_gems: () -> untyped

  def self.mkdir_p: (untyped path, ?untyped options) -> untyped

  # @return [Hash] Environment present before
  # [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) was activated
  def self.original_env: () -> untyped

  def self.read_file: (untyped file) -> untyped

  def self.require: (*untyped groups) -> untyped

  def self.require_thor_actions: () -> untyped

  def self.requires_sudo?: () -> untyped

  def self.reset!: () -> untyped

  def self.reset_paths!: () -> untyped

  def self.reset_rubygems!: () -> untyped

  def self.rm_rf: (untyped path) -> untyped

  def self.root: () -> untyped

  def self.ruby_scope: () -> untyped

  def self.rubygems: () -> untyped

  def self.settings: () -> untyped

  def self.setup: (*untyped groups) -> untyped

  def self.specs_path: () -> untyped

  def self.sudo: (untyped str) -> untyped

  def self.system_bindir: () -> untyped

  def self.tmp: (?untyped name) -> untyped

  def self.tmp_home_path: (untyped login, untyped warning) -> untyped

  def self.ui: () -> untyped

  def self.ui=: (untyped ui) -> untyped

  def self.use_system_gems?: () -> untyped

  def self.user_bundle_path: (?untyped dir) -> untyped

  def self.user_cache: () -> untyped

  def self.user_home: () -> untyped

  def self.which: (untyped executable) -> untyped

  # @deprecated Use `with\_unbundled\_env` instead
  def self.with_clean_env: () { () -> untyped } -> untyped

  def self.with_unbundled_env: () { () -> untyped } -> untyped

  # Run block with environment present before
  # [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) was activated
  def self.with_original_env: () { () -> untyped } -> untyped
end

Bundler::FREEBSD: untyped

Bundler::NULL: untyped

Bundler::ORIGINAL_ENV: untyped

Bundler::SUDO_MUTEX: untyped

Bundler::VERSION: untyped

Bundler::WINDOWS: untyped

class Bundler::APIResponseMismatchError < Bundler::BundlerError
  def status_code: () -> untyped
end

# Represents metadata from when the
# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) gem was built.
module Bundler::BuildMetadata
  # A string representing the date the bundler gem was built.
  def self.built_at: () -> untyped

  # The SHA for the git commit the bundler gem was built from.
  def self.git_commit_sha: () -> untyped

  # Whether this is an official release build of
  # [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html).
  def self.release?: () -> untyped

  # A hash representation of the build metadata.
  def self.to_h: () -> untyped
end

class Bundler::BundlerError < StandardError
  def self.all_errors: () -> untyped

  def self.status_code: (untyped code) -> untyped
end

class Bundler::CurrentRuby
  def jruby?: () -> untyped

  def jruby_18?: () -> untyped

  def jruby_19?: () -> untyped

  def jruby_1?: () -> untyped

  def jruby_20?: () -> untyped

  def jruby_21?: () -> untyped

  def jruby_22?: () -> untyped

  def jruby_23?: () -> untyped

  def jruby_24?: () -> untyped

  def jruby_25?: () -> untyped

  def jruby_26?: () -> untyped

  def jruby_27?: () -> untyped

  def jruby_2?: () -> untyped

  def maglev?: () -> untyped

  def maglev_18?: () -> untyped

  def maglev_19?: () -> untyped

  def maglev_1?: () -> untyped

  def maglev_20?: () -> untyped

  def maglev_21?: () -> untyped

  def maglev_22?: () -> untyped

  def maglev_23?: () -> untyped

  def maglev_24?: () -> untyped

  def maglev_25?: () -> untyped

  def maglev_26?: () -> untyped

  def maglev_27?: () -> untyped

  def maglev_2?: () -> untyped

  def mingw?: () -> untyped

  def mingw_18?: () -> untyped

  def mingw_19?: () -> untyped

  def mingw_1?: () -> untyped

  def mingw_20?: () -> untyped

  def mingw_21?: () -> untyped

  def mingw_22?: () -> untyped

  def mingw_23?: () -> untyped

  def mingw_24?: () -> untyped

  def mingw_25?: () -> untyped

  def mingw_26?: () -> untyped

  def mingw_27?: () -> untyped

  def mingw_2?: () -> untyped

  def mri?: () -> untyped

  def mri_18?: () -> untyped

  def mri_19?: () -> untyped

  def mri_1?: () -> untyped

  def mri_20?: () -> untyped

  def mri_21?: () -> untyped

  def mri_22?: () -> untyped

  def mri_23?: () -> untyped

  def mri_24?: () -> untyped

  def mri_25?: () -> untyped

  def mri_26?: () -> untyped

  def mri_27?: () -> untyped

  def mri_2?: () -> untyped

  def mswin64?: () -> untyped

  def mswin64_18?: () -> untyped

  def mswin64_19?: () -> untyped

  def mswin64_1?: () -> untyped

  def mswin64_20?: () -> untyped

  def mswin64_21?: () -> untyped

  def mswin64_22?: () -> untyped

  def mswin64_23?: () -> untyped

  def mswin64_24?: () -> untyped

  def mswin64_25?: () -> untyped

  def mswin64_26?: () -> untyped

  def mswin64_27?: () -> untyped

  def mswin64_2?: () -> untyped

  def mswin?: () -> untyped

  def mswin_18?: () -> untyped

  def mswin_19?: () -> untyped

  def mswin_1?: () -> untyped

  def mswin_20?: () -> untyped

  def mswin_21?: () -> untyped

  def mswin_22?: () -> untyped

  def mswin_23?: () -> untyped

  def mswin_24?: () -> untyped

  def mswin_25?: () -> untyped

  def mswin_26?: () -> untyped

  def mswin_27?: () -> untyped

  def mswin_2?: () -> untyped

  def on_18?: () -> untyped

  def on_19?: () -> untyped

  def on_1?: () -> untyped

  def on_20?: () -> untyped

  def on_21?: () -> untyped

  def on_22?: () -> untyped

  def on_23?: () -> untyped

  def on_24?: () -> untyped

  def on_25?: () -> untyped

  def on_26?: () -> untyped

  def on_27?: () -> untyped

  def on_2?: () -> untyped

  def rbx?: () -> untyped

  def rbx_18?: () -> untyped

  def rbx_19?: () -> untyped

  def rbx_1?: () -> untyped

  def rbx_20?: () -> untyped

  def rbx_21?: () -> untyped

  def rbx_22?: () -> untyped

  def rbx_23?: () -> untyped

  def rbx_24?: () -> untyped

  def rbx_25?: () -> untyped

  def rbx_26?: () -> untyped

  def rbx_27?: () -> untyped

  def rbx_2?: () -> untyped

  def ruby?: () -> untyped

  def ruby_18?: () -> untyped

  def ruby_19?: () -> untyped

  def ruby_1?: () -> untyped

  def ruby_20?: () -> untyped

  def ruby_21?: () -> untyped

  def ruby_22?: () -> untyped

  def ruby_23?: () -> untyped

  def ruby_24?: () -> untyped

  def ruby_25?: () -> untyped

  def ruby_26?: () -> untyped

  def ruby_27?: () -> untyped

  def ruby_2?: () -> untyped

  def truffleruby?: () -> untyped

  def truffleruby_18?: () -> untyped

  def truffleruby_19?: () -> untyped

  def truffleruby_1?: () -> untyped

  def truffleruby_20?: () -> untyped

  def truffleruby_21?: () -> untyped

  def truffleruby_22?: () -> untyped

  def truffleruby_23?: () -> untyped

  def truffleruby_24?: () -> untyped

  def truffleruby_25?: () -> untyped

  def truffleruby_26?: () -> untyped

  def truffleruby_27?: () -> untyped

  def truffleruby_2?: () -> untyped

  def x64_mingw?: () -> untyped

  def x64_mingw_18?: () -> untyped

  def x64_mingw_19?: () -> untyped

  def x64_mingw_1?: () -> untyped

  def x64_mingw_20?: () -> untyped

  def x64_mingw_21?: () -> untyped

  def x64_mingw_22?: () -> untyped

  def x64_mingw_23?: () -> untyped

  def x64_mingw_24?: () -> untyped

  def x64_mingw_25?: () -> untyped

  def x64_mingw_26?: () -> untyped

  def x64_mingw_27?: () -> untyped

  def x64_mingw_2?: () -> untyped
end

Bundler::CurrentRuby::KNOWN_MAJOR_VERSIONS: untyped

Bundler::CurrentRuby::KNOWN_MINOR_VERSIONS: untyped

Bundler::CurrentRuby::KNOWN_PLATFORMS: untyped

class Bundler::CyclicDependencyError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::Definition
  include ::Bundler::GemHelpers

  def add_current_platform: () -> untyped

  def add_platform: (untyped platform) -> untyped

  def current_dependencies: () -> untyped

  def dependencies: () -> Array[::Bundler::Dependency]

  def ensure_equivalent_gemfile_and_lockfile: (?untyped explicit_flag) -> untyped

  def find_indexed_specs: (untyped current_spec) -> untyped

  def find_resolved_spec: (untyped current_spec) -> untyped

  def gem_version_promoter: () -> untyped

  def gemfiles: () -> untyped

  def groups: () -> untyped

  def has_local_dependencies?: () -> untyped

  def has_rubygems_remotes?: () -> untyped

  def index: () -> untyped

  def initialize: (untyped lockfile, untyped dependencies, untyped sources, untyped unlock, ?untyped ruby_version, ?untyped optional_groups, ?untyped gemfiles) -> void

  def lock: (untyped file, ?untyped preserve_unknown_sections) -> untyped

  def locked_bundler_version: () -> untyped

  def locked_deps: () -> untyped

  def locked_gems: () -> Bundler::LockfileParser

  def locked_ruby_version: () -> untyped

  def locked_ruby_version_object: () -> untyped

  def lockfile: () -> Pathname

  def missing_specs: () -> untyped

  def missing_specs?: () -> untyped

  def new_platform?: () -> untyped

  def new_specs: () -> untyped

  def nothing_changed?: () -> untyped

  def platforms: () -> untyped

  def remove_platform: (untyped platform) -> untyped

  def removed_specs: () -> untyped

  def requested_specs: () -> untyped

  def requires: () -> untyped

  # Resolve all the dependencies specified in Gemfile. It ensures that
  # dependencies that have been already resolved via locked file and are fresh
  # are reused when resolving dependencies
  #
  # @return [SpecSet] resolved dependencies
  def resolve: () -> untyped

  def resolve_remotely!: () -> untyped

  def resolve_with_cache!: () -> untyped

  def ruby_version: () -> untyped

  def spec_git_paths: () -> untyped

  # For given dependency list returns a SpecSet with Gemspec of all the required
  # dependencies.
  #
  # ```
  # 1. The method first resolves the dependencies specified in Gemfile
  # 2. After that it tries and fetches gemspec of resolved dependencies
  # ```
  #
  # @return [Bundler::SpecSet]
  def specs: () -> untyped

  def specs_for: (untyped groups) -> untyped

  def to_lock: () -> untyped

  def unlocking?: () -> untyped

  def validate_platforms!: () -> untyped

  def validate_ruby!: () -> untyped

  def validate_runtime!: () -> untyped

  def self.build: (untyped gemfile, untyped lockfile, untyped unlock) -> untyped
end

class Bundler::DepProxy
  def ==: (untyped other) -> untyped

  def __platform: () -> untyped

  def dep: () -> untyped

  def eql?: (untyped other) -> untyped

  def hash: () -> untyped

  def initialize: (untyped dep, untyped platform) -> void

  def name: () -> untyped

  def requirement: () -> untyped

  def to_s: () -> untyped

  def type: () -> untyped
end

class Bundler::Dependency < Gem::Dependency
  def autorequire: () -> untyped

  def current_env?: () -> untyped

  def current_platform?: () -> untyped

  def gem_platforms: (untyped valid_platforms) -> untyped

  def gemfile: () -> untyped

  def groups: () -> untyped

  def initialize: (untyped name, untyped version, ?untyped options) { () -> untyped } -> void

  def platforms: () -> untyped

  def should_include?: () -> untyped

  def specific?: () -> untyped

  def to_lock: () -> untyped
end

Bundler::Dependency::PLATFORM_MAP: untyped

Bundler::Dependency::REVERSE_PLATFORM_MAP: untyped

class Bundler::DeprecatedError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::Dsl
  @source: untyped

  @sources: untyped

  @git_sources: untyped

  @dependencies: untyped

  @groups: untyped

  @install_conditionals: untyped

  @optional_groups: untyped

  @platforms: untyped

  @env: untyped

  @ruby_version: untyped

  @gemspecs: untyped

  @gemfile: untyped

  @gemfiles: untyped

  @valid_keys: untyped

  include RubyDsl

  def self.evaluate: (untyped gemfile, untyped lockfile, untyped unlock) -> untyped

  VALID_PLATFORMS: untyped

  VALID_KEYS: ::Array["group" | "groups" | "git" | "path" | "glob" | "name" | "branch" | "ref" | "tag" | "require" | "submodules" | "platform" | "platforms" | "source" | "install_if" | "force_ruby_platform"]

  GITHUB_PULL_REQUEST_URL: ::Regexp

  GITLAB_MERGE_REQUEST_URL: ::Regexp

  attr_reader gemspecs: untyped

  attr_reader gemfile: untyped

  attr_accessor dependencies: untyped

  def initialize: () -> void

  def eval_gemfile: (untyped gemfile, ?untyped? contents) -> untyped

  def gemspec: (?path: ::String, ?glob: ::String, ?name: ::String, ?development_group: ::Symbol) -> void

  def gem: (untyped name, *untyped args) -> void

  def source: (::String source, ?type: ::Symbol) ?{ (?) -> untyped } -> void

  def git_source: (untyped name) ?{ (?) -> untyped } -> untyped

  def path: (untyped path, ?::Hash[untyped, untyped] options) ?{ (?) -> untyped } -> untyped

  def git: (untyped uri, ?::Hash[untyped, untyped] options) ?{ (?) -> untyped } -> untyped

  def github: (untyped repo, ?::Hash[untyped, untyped] options) ?{ () -> untyped } -> untyped

  def to_definition: (untyped lockfile, untyped unlock) -> untyped

  def group: (*untyped args) { () -> untyped } -> untyped

  def install_if: (*untyped args) { () -> untyped } -> untyped

  def platforms: (*untyped platforms) { () -> untyped } -> untyped

  alias platform platforms

  def env: (untyped name) { () -> untyped } -> untyped

  def plugin: (*untyped args) -> nil

  def method_missing: (untyped name, *untyped args) -> untyped

  def check_primary_source_safety: () -> untyped

  private

  def add_dependency: (untyped name, ?untyped? version, ?::Hash[untyped, untyped] options) -> (nil | untyped)

  def with_gemfile: (untyped gemfile) { (untyped) -> untyped } -> untyped

  def add_git_sources: () -> untyped

  def with_source: (untyped source) ?{ () -> untyped } -> untyped

  def normalize_hash: (untyped opts) -> untyped

  def valid_keys: () -> untyped

  def normalize_options: (untyped name, untyped version, untyped opts) -> untyped

  def normalize_group_options: (untyped opts, untyped groups) -> untyped

  def validate_keys: (untyped command, untyped opts, untyped valid_keys) -> (true | untyped)

  def normalize_source: (untyped source) -> untyped

  def deprecate_legacy_windows_platforms: (untyped platforms) -> (nil | untyped)

  def check_path_source_safety: () -> (nil | untyped)

  def check_rubygems_source_safety: () -> (untyped | nil)

  def multiple_global_source_warning: () -> untyped

  class DSLError < GemfileError
    @status_code: untyped

    @description: untyped

    @dsl_path: untyped

    @backtrace: untyped

    @contents: untyped

    @to_s: untyped

    # @return [::String] the description that should be presented to the user.
    #
    attr_reader description: ::String

    # @return [::String] the path of the dsl file that raised the exception.
    #
    attr_reader dsl_path: ::String

    # @return [::Exception] the backtrace of the exception raised by the
    #         evaluation of the dsl file.
    #
    attr_reader backtrace: ::Exception

    # @param [::Exception] backtrace @see backtrace
    # @param [::String]    dsl_path  @see dsl_path
    #
    def initialize: (untyped description, ::String dsl_path, ::Exception backtrace, ?untyped? contents) -> void

    def status_code: () -> untyped

    # @return [::String] the contents of the DSL that cause the exception to
    #         be raised.
    #
    def contents: () -> ::String

    # The message of the exception reports the content of podspec for the
    # line that generated the original exception.
    #
    # @example Output
    #
    #   Invalid podspec at `RestKit.podspec` - undefined method
    #   `exclude_header_search_paths=' for #<Pod::Specification for
    #   `RestKit/Network (0.9.3)`>
    #
    #       from spec-repos/master/RestKit/0.9.3/RestKit.podspec:36
    #       -------------------------------------------
    #           # because it would break: #import <CoreData/CoreData.h>
    #    >      ns.exclude_header_search_paths = 'Code/RestKit.h'
    #         end
    #       -------------------------------------------
    #
    # @return [::String] the message of the exception.
    #
    def to_s: () -> ::String

    private

    def parse_line_number_from_description: () -> ::Array[untyped]
  end

  def gemfile_root: () -> untyped
end

# used for Creating Specifications from the Gemcutter Endpoint
class Bundler::EndpointSpecification < Gem::Specification
  def __swap__: (untyped spec) -> untyped

  def _local_specification: () -> untyped

  # needed for bundle clean
  def bindir: () -> untyped

  def checksum: () -> untyped

  def dependencies: () -> untyped

  def dependencies=: (untyped dependencies) -> untyped

  # needed for binstubs
  def executables: () -> untyped

  # needed for "with native extensions" during install
  def extensions: () -> untyped

  def fetch_platform: () -> untyped

  def initialize: (untyped name, untyped version, untyped platform, untyped dependencies, ?untyped metadata) -> void

  # needed for inline
  def load_paths: () -> untyped

  def name: () -> untyped

  def platform: () -> untyped

  # needed for post\_install\_messages during install
  def post_install_message: () -> untyped

  def remote: () -> untyped

  def remote=: (untyped remote) -> untyped

  # needed for standalone, load required\_paths from local gemspec after the gem
  # is installed
  def require_paths: () -> untyped

  def required_ruby_version: () -> untyped

  def required_rubygems_version: () -> untyped

  def source: () -> untyped

  def source=: (untyped source) -> untyped

  def version: () -> untyped
end

Bundler::EndpointSpecification::Elem: untyped

Bundler::EndpointSpecification::ILLFORMED_MESSAGE: untyped

class Bundler::EnvironmentPreserver
  # @return [Hash]
  def backup: () -> untyped

  def initialize: (untyped env, untyped keys) -> void

  # @return [Hash]
  def restore: () -> untyped
end

Bundler::EnvironmentPreserver::BUNDLER_KEYS: untyped

Bundler::EnvironmentPreserver::BUNDLER_PREFIX: untyped

Bundler::EnvironmentPreserver::INTENTIONALLY_NIL: untyped

class Bundler::FeatureFlag
  def allow_bundler_dependency_conflicts?: () -> untyped

  def allow_offline_install?: () -> untyped

  def auto_clean_without_path?: () -> untyped

  def auto_config_jobs?: () -> untyped

  def bundler_10_mode?: () -> untyped

  def bundler_1_mode?: () -> untyped

  def bundler_2_mode?: () -> untyped

  def bundler_3_mode?: () -> untyped

  def bundler_4_mode?: () -> untyped

  def bundler_5_mode?: () -> untyped

  def bundler_6_mode?: () -> untyped

  def bundler_7_mode?: () -> untyped

  def bundler_8_mode?: () -> untyped

  def bundler_9_mode?: () -> untyped

  def cache_all?: () -> untyped

  def cache_command_is_package?: () -> untyped

  def console_command?: () -> untyped

  def default_cli_command: () -> untyped

  def default_install_uses_path?: () -> untyped

  def deployment_means_frozen?: () -> untyped

  def disable_multisource?: () -> untyped

  def error_on_stderr?: () -> untyped

  def forget_cli_options?: () -> untyped

  def global_gem_cache?: () -> untyped

  def init_gems_rb?: () -> untyped

  def initialize: (untyped bundler_version) -> void

  def list_command?: () -> untyped

  def lockfile_uses_separate_rubygems_sources?: () -> untyped

  def only_update_to_newer_versions?: () -> untyped

  def path_relative_to_cwd?: () -> untyped

  def plugins?: () -> untyped

  def prefer_gems_rb?: () -> untyped

  def print_only_version_number?: () -> untyped

  def setup_makes_kernel_gem_public?: () -> untyped

  def skip_default_git_sources?: () -> untyped

  def specific_platform?: () -> untyped

  def suppress_install_using_messages?: () -> untyped

  def unlock_source_unlocks_spec?: () -> untyped

  def update_requires_all_flag?: () -> untyped

  def use_gem_version_promoter_for_major_updates?: () -> untyped

  def viz_command?: () -> untyped
end

# # fileutils.rb
#
# Copyright (c) 2000-2007 Minero Aoki
#
# This program is free software. You can distribute/modify this program under
# the same terms of ruby.
#
# ## module [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
#
# Namespace for several file utility methods for copying, moving, removing, etc.
#
# ### [`Module`](https://docs.ruby-lang.org/en/2.7.0/Module.html) Functions
#
# ```ruby
# require 'bundler/vendor/fileutils/lib/fileutils'
#
# Bundler::FileUtils.cd(dir, **options)
# Bundler::FileUtils.cd(dir, **options) {|dir| block }
# Bundler::FileUtils.pwd()
# Bundler::FileUtils.mkdir(dir, **options)
# Bundler::FileUtils.mkdir(list, **options)
# Bundler::FileUtils.mkdir_p(dir, **options)
# Bundler::FileUtils.mkdir_p(list, **options)
# Bundler::FileUtils.rmdir(dir, **options)
# Bundler::FileUtils.rmdir(list, **options)
# Bundler::FileUtils.ln(target, link, **options)
# Bundler::FileUtils.ln(targets, dir, **options)
# Bundler::FileUtils.ln_s(target, link, **options)
# Bundler::FileUtils.ln_s(targets, dir, **options)
# Bundler::FileUtils.ln_sf(target, link, **options)
# Bundler::FileUtils.cp(src, dest, **options)
# Bundler::FileUtils.cp(list, dir, **options)
# Bundler::FileUtils.cp_r(src, dest, **options)
# Bundler::FileUtils.cp_r(list, dir, **options)
# Bundler::FileUtils.mv(src, dest, **options)
# Bundler::FileUtils.mv(list, dir, **options)
# Bundler::FileUtils.rm(list, **options)
# Bundler::FileUtils.rm_r(list, **options)
# Bundler::FileUtils.rm_rf(list, **options)
# Bundler::FileUtils.install(src, dest, **options)
# Bundler::FileUtils.chmod(mode, list, **options)
# Bundler::FileUtils.chmod_R(mode, list, **options)
# Bundler::FileUtils.chown(user, group, list, **options)
# Bundler::FileUtils.chown_R(user, group, list, **options)
# Bundler::FileUtils.touch(list, **options)
# ```
#
# Possible `options` are:
#
# `:force`
# :   forced operation (rewrite files if exist, remove directories if not empty,
#     etc.);
# `:verbose`
# :   print command to be run, in bash syntax, before performing it;
# `:preserve`
# :   preserve object's group, user and modification time on copying;
# `:noop`
# :   no changes are made (usable in combination with `:verbose` which will
#     print the command to run)
#
#
# Each method documents the options that it honours. See also
# [`::commands`](https://docs.ruby-lang.org/en/2.7.0/FileUtils.html#method-c-commands),
# [`::options`](https://docs.ruby-lang.org/en/2.7.0/FileUtils.html#method-c-options)
# and
# [`::options_of`](https://docs.ruby-lang.org/en/2.7.0/FileUtils.html#method-c-options_of)
# methods to introspect which command have which options.
#
# All methods that have the concept of a "source" file or directory can take
# either one file or a list of files in that argument. See the method
# documentation for examples.
#
# There are some 'low level' methods, which do not accept keyword arguments:
#
# ```ruby
# Bundler::FileUtils.copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
# Bundler::FileUtils.copy_file(src, dest, preserve = false, dereference = true)
# Bundler::FileUtils.copy_stream(srcstream, deststream)
# Bundler::FileUtils.remove_entry(path, force = false)
# Bundler::FileUtils.remove_entry_secure(path, force = false)
# Bundler::FileUtils.remove_file(path, force = false)
# Bundler::FileUtils.compare_file(path_a, path_b)
# Bundler::FileUtils.compare_stream(stream_a, stream_b)
# Bundler::FileUtils.uptodate?(file, cmp_list)
# ```
#
# ## module [`Bundler::FileUtils::Verbose`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils/Verbose.html)
#
# This module has all methods of
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
# module, but it outputs messages before acting. This equates to passing the
# `:verbose` flag to methods in
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html).
#
# ## module [`Bundler::FileUtils::NoWrite`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils/NoWrite.html)
#
# This module has all methods of
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
# module, but never changes files/directories.  This equates to passing the
# `:noop` flag to methods in
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html).
#
# ## module [`Bundler::FileUtils::DryRun`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils/DryRun.html)
#
# This module has all methods of
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
# module, but never changes files/directories.  This equates to passing the
# `:noop` and `:verbose` flags to methods in
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html).
module Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_

  extend ::Bundler::FileUtils::StreamUtils_

  def self.cd: (untyped dir, ?verbose: untyped verbose) { () -> untyped } -> untyped

  def self.chdir: (untyped dir, ?verbose: untyped verbose) { () -> untyped } -> untyped

  def self.chmod: (untyped mode, untyped list, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.chmod_R: (untyped mode, untyped list, ?noop: untyped noop, ?verbose: untyped verbose, ?force: untyped force) -> untyped

  def self.chown: (untyped user, untyped group, untyped list, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.chown_R: (untyped user, untyped group, untyped list, ?noop: untyped noop, ?verbose: untyped verbose, ?force: untyped force) -> untyped

  def self.cmp: (untyped a, untyped b) -> untyped

  def self.collect_method: (untyped opt) -> untyped

  # Returns an [`Array`](https://docs.ruby-lang.org/en/2.7.0/Array.html) of
  # names of high-level methods that accept any keyword arguments.
  #
  # ```ruby
  # p Bundler::FileUtils.commands  #=> ["chmod", "cp", "cp_r", "install", ...]
  # ```
  def self.commands: () -> untyped

  def self.compare_file: (untyped a, untyped b) -> untyped

  def self.compare_stream: (untyped a, untyped b) -> untyped

  def self.copy: (untyped src, untyped dest, ?preserve: untyped preserve, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.copy_entry: (untyped src, untyped dest, ?untyped preserve, ?untyped dereference_root, ?untyped remove_destination) -> untyped

  def self.copy_file: (untyped src, untyped dest, ?untyped preserve, ?untyped dereference) -> untyped

  def self.copy_stream: (untyped src, untyped dest) -> untyped

  def self.cp: (untyped src, untyped dest, ?preserve: untyped preserve, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.cp_r: (untyped src, untyped dest, ?preserve: untyped preserve, ?noop: untyped noop, ?verbose: untyped verbose, ?dereference_root: untyped dereference_root, ?remove_destination: untyped remove_destination) -> untyped

  # Alias for:
  # [`pwd`](https://docs.ruby-lang.org/en/2.7.0/FileUtils.html#method-i-pwd)
  def self.getwd: () -> untyped

  def self.have_option?: (untyped mid, untyped opt) -> untyped

  def self.identical?: (untyped a, untyped b) -> untyped

  def self.install: (untyped src, untyped dest, ?mode: untyped mode, ?owner: untyped owner, ?group: untyped group, ?preserve: untyped preserve, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.link: (untyped src, untyped dest, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.ln: (untyped src, untyped dest, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.ln_s: (untyped src, untyped dest, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.ln_sf: (untyped src, untyped dest, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.makedirs: (untyped list, ?mode: untyped mode, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.mkdir: (untyped list, ?mode: untyped mode, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.mkdir_p: (untyped list, ?mode: untyped mode, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.mkpath: (untyped list, ?mode: untyped mode, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.move: (untyped src, untyped dest, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose, ?secure: untyped secure) -> untyped

  def self.mv: (untyped src, untyped dest, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose, ?secure: untyped secure) -> untyped

  # Returns an [`Array`](https://docs.ruby-lang.org/en/2.7.0/Array.html) of
  # option names.
  #
  # ```ruby
  # p Bundler::FileUtils.options  #=> ["noop", "force", "verbose", "preserve", "mode"]
  # ```
  def self.options: () -> untyped

  def self.options_of: (untyped mid) -> untyped

  def self.private_module_function: (untyped name) -> untyped

  # Returns the name of the current directory.
  #
  # Also aliased as:
  # [`getwd`](https://docs.ruby-lang.org/en/2.7.0/FileUtils.html#method-c-getwd)
  def self.pwd: () -> untyped

  def self.remove: (untyped list, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.remove_dir: (untyped path, ?untyped force) -> untyped

  def self.remove_entry: (untyped path, ?untyped force) -> untyped

  def self.remove_entry_secure: (untyped path, ?untyped force) -> untyped

  def self.remove_file: (untyped path, ?untyped force) -> untyped

  def self.rm: (untyped list, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.rm_f: (untyped list, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.rm_r: (untyped list, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose, ?secure: untyped secure) -> untyped

  def self.rm_rf: (untyped list, ?noop: untyped noop, ?verbose: untyped verbose, ?secure: untyped secure) -> untyped

  def self.rmdir: (untyped list, ?parents: untyped parents, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.rmtree: (untyped list, ?noop: untyped noop, ?verbose: untyped verbose, ?secure: untyped secure) -> untyped

  def self.safe_unlink: (untyped list, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.symlink: (untyped src, untyped dest, ?force: untyped force, ?noop: untyped noop, ?verbose: untyped verbose) -> untyped

  def self.touch: (untyped list, ?noop: untyped noop, ?verbose: untyped verbose, ?mtime: untyped mtime, ?nocreate: untyped nocreate) -> untyped

  def self.uptodate?: (untyped new, untyped old_list) -> untyped
end

Bundler::FileUtils::LOW_METHODS: untyped

Bundler::FileUtils::METHODS: untyped

Bundler::FileUtils::OPT_TABLE: untyped

# This module has all methods of
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
# module, but never changes files/directories, with printing message before
# acting. This equates to passing the `:noop` and `:verbose` flag to methods in
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html).
module Bundler::FileUtils::DryRun
  include ::Bundler::FileUtils::LowMethods

  include ::Bundler::FileUtils

  include ::Bundler::FileUtils::StreamUtils_

  extend ::Bundler::FileUtils::DryRun

  extend ::Bundler::FileUtils::LowMethods

  extend ::Bundler::FileUtils

  extend ::Bundler::FileUtils::StreamUtils_

  def self.cd: (*untyped _) -> untyped

  def self.chdir: (*untyped _) -> untyped

  def self.chmod: (*untyped args, **untyped options) -> untyped

  def self.chmod_R: (*untyped args, **untyped options) -> untyped

  def self.chown: (*untyped args, **untyped options) -> untyped

  def self.chown_R: (*untyped args, **untyped options) -> untyped

  def self.cmp: (*untyped _) -> untyped

  def self.compare_file: (*untyped _) -> untyped

  def self.compare_stream: (*untyped _) -> untyped

  def self.copy: (*untyped args, **untyped options) -> untyped

  def self.copy_entry: (*untyped _) -> untyped

  def self.copy_file: (*untyped _) -> untyped

  def self.copy_stream: (*untyped _) -> untyped

  def self.cp: (*untyped args, **untyped options) -> untyped

  def self.cp_r: (*untyped args, **untyped options) -> untyped

  def self.getwd: (*untyped _) -> untyped

  def self.identical?: (*untyped _) -> untyped

  def self.install: (*untyped args, **untyped options) -> untyped

  def self.link: (*untyped args, **untyped options) -> untyped

  def self.ln: (*untyped args, **untyped options) -> untyped

  def self.ln_s: (*untyped args, **untyped options) -> untyped

  def self.ln_sf: (*untyped args, **untyped options) -> untyped

  def self.makedirs: (*untyped args, **untyped options) -> untyped

  def self.mkdir: (*untyped args, **untyped options) -> untyped

  def self.mkdir_p: (*untyped args, **untyped options) -> untyped

  def self.mkpath: (*untyped args, **untyped options) -> untyped

  def self.move: (*untyped args, **untyped options) -> untyped

  def self.mv: (*untyped args, **untyped options) -> untyped

  def self.pwd: (*untyped _) -> untyped

  def self.remove: (*untyped args, **untyped options) -> untyped

  def self.remove_dir: (*untyped _) -> untyped

  def self.remove_entry: (*untyped _) -> untyped

  def self.remove_entry_secure: (*untyped _) -> untyped

  def self.remove_file: (*untyped _) -> untyped

  def self.rm: (*untyped args, **untyped options) -> untyped

  def self.rm_f: (*untyped args, **untyped options) -> untyped

  def self.rm_r: (*untyped args, **untyped options) -> untyped

  def self.rm_rf: (*untyped args, **untyped options) -> untyped

  def self.rmdir: (*untyped args, **untyped options) -> untyped

  def self.rmtree: (*untyped args, **untyped options) -> untyped

  def self.safe_unlink: (*untyped args, **untyped options) -> untyped

  def self.symlink: (*untyped args, **untyped options) -> untyped

  def self.touch: (*untyped args, **untyped options) -> untyped

  def self.uptodate?: (*untyped _) -> untyped
end

class Bundler::FileUtils::Entry_
  include ::Bundler::FileUtils::StreamUtils_

  def blockdev?: () -> untyped

  def chardev?: () -> untyped

  def chmod: (untyped mode) -> untyped

  def chown: (untyped uid, untyped gid) -> untyped

  def copy: (untyped dest) -> untyped

  def copy_file: (untyped dest) -> untyped

  def copy_metadata: (untyped path) -> untyped

  def dereference?: () -> untyped

  def directory?: () -> untyped

  def door?: () -> untyped

  def entries: () -> untyped

  def exist?: () -> untyped

  def file?: () -> untyped

  def initialize: (untyped a, ?untyped b, ?untyped deref) -> void

  def inspect: () -> untyped

  def lstat: () -> untyped

  def lstat!: () -> untyped

  def path: () -> untyped

  def pipe?: () -> untyped

  def platform_support: () -> untyped

  def postorder_traverse: () -> untyped

  def prefix: () -> untyped

  def preorder_traverse: () -> untyped

  def rel: () -> untyped

  def remove: () -> untyped

  def remove_dir1: () -> untyped

  def remove_file: () -> untyped

  def socket?: () -> untyped

  def stat: () -> untyped

  def stat!: () -> untyped

  def symlink?: () -> untyped

  def traverse: () -> untyped

  def wrap_traverse: (untyped pre, untyped post) -> untyped
end

Bundler::FileUtils::Entry_::DIRECTORY_TERM: untyped

Bundler::FileUtils::Entry_::SYSCASE: untyped

Bundler::FileUtils::Entry_::S_IF_DOOR: untyped

module Bundler::FileUtils::LowMethods
end

# This module has all methods of
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
# module, but never changes files/directories.  This equates to passing the
# `:noop` flag to methods in
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html).
module Bundler::FileUtils::NoWrite
  include ::Bundler::FileUtils::LowMethods

  include ::Bundler::FileUtils

  include ::Bundler::FileUtils::StreamUtils_

  extend ::Bundler::FileUtils::NoWrite

  extend ::Bundler::FileUtils::LowMethods

  extend ::Bundler::FileUtils

  extend ::Bundler::FileUtils::StreamUtils_

  def self.cd: (*untyped _) -> untyped

  def self.chdir: (*untyped _) -> untyped

  def self.chmod: (*untyped args, **untyped options) -> untyped

  def self.chmod_R: (*untyped args, **untyped options) -> untyped

  def self.chown: (*untyped args, **untyped options) -> untyped

  def self.chown_R: (*untyped args, **untyped options) -> untyped

  def self.cmp: (*untyped _) -> untyped

  def self.compare_file: (*untyped _) -> untyped

  def self.compare_stream: (*untyped _) -> untyped

  def self.copy: (*untyped args, **untyped options) -> untyped

  def self.copy_entry: (*untyped _) -> untyped

  def self.copy_file: (*untyped _) -> untyped

  def self.copy_stream: (*untyped _) -> untyped

  def self.cp: (*untyped args, **untyped options) -> untyped

  def self.cp_r: (*untyped args, **untyped options) -> untyped

  def self.getwd: (*untyped _) -> untyped

  def self.identical?: (*untyped _) -> untyped

  def self.install: (*untyped args, **untyped options) -> untyped

  def self.link: (*untyped args, **untyped options) -> untyped

  def self.ln: (*untyped args, **untyped options) -> untyped

  def self.ln_s: (*untyped args, **untyped options) -> untyped

  def self.ln_sf: (*untyped args, **untyped options) -> untyped

  def self.makedirs: (*untyped args, **untyped options) -> untyped

  def self.mkdir: (*untyped args, **untyped options) -> untyped

  def self.mkdir_p: (*untyped args, **untyped options) -> untyped

  def self.mkpath: (*untyped args, **untyped options) -> untyped

  def self.move: (*untyped args, **untyped options) -> untyped

  def self.mv: (*untyped args, **untyped options) -> untyped

  def self.pwd: (*untyped _) -> untyped

  def self.remove: (*untyped args, **untyped options) -> untyped

  def self.remove_dir: (*untyped _) -> untyped

  def self.remove_entry: (*untyped _) -> untyped

  def self.remove_entry_secure: (*untyped _) -> untyped

  def self.remove_file: (*untyped _) -> untyped

  def self.rm: (*untyped args, **untyped options) -> untyped

  def self.rm_f: (*untyped args, **untyped options) -> untyped

  def self.rm_r: (*untyped args, **untyped options) -> untyped

  def self.rm_rf: (*untyped args, **untyped options) -> untyped

  def self.rmdir: (*untyped args, **untyped options) -> untyped

  def self.rmtree: (*untyped args, **untyped options) -> untyped

  def self.safe_unlink: (*untyped args, **untyped options) -> untyped

  def self.symlink: (*untyped args, **untyped options) -> untyped

  def self.touch: (*untyped args, **untyped options) -> untyped

  def self.uptodate?: (*untyped _) -> untyped
end

module Bundler::FileUtils::StreamUtils_
end

# This module has all methods of
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html)
# module, but it outputs messages before acting. This equates to passing the
# `:verbose` flag to methods in
# [`Bundler::FileUtils`](https://docs.ruby-lang.org/en/2.7.0/Bundler/FileUtils.html).
module Bundler::FileUtils::Verbose
  include ::Bundler::FileUtils

  include ::Bundler::FileUtils::StreamUtils_

  extend ::Bundler::FileUtils::Verbose

  extend ::Bundler::FileUtils

  extend ::Bundler::FileUtils::StreamUtils_

  def self.cd: (*untyped args, **untyped options) -> untyped

  def self.chdir: (*untyped args, **untyped options) -> untyped

  def self.chmod: (*untyped args, **untyped options) -> untyped

  def self.chmod_R: (*untyped args, **untyped options) -> untyped

  def self.chown: (*untyped args, **untyped options) -> untyped

  def self.chown_R: (*untyped args, **untyped options) -> untyped

  def self.cmp: (untyped a, untyped b) -> untyped

  def self.compare_file: (untyped a, untyped b) -> untyped

  def self.compare_stream: (untyped a, untyped b) -> untyped

  def self.copy: (*untyped args, **untyped options) -> untyped

  def self.copy_entry: (untyped src, untyped dest, ?untyped preserve, ?untyped dereference_root, ?untyped remove_destination) -> untyped

  def self.copy_file: (untyped src, untyped dest, ?untyped preserve, ?untyped dereference) -> untyped

  def self.copy_stream: (untyped src, untyped dest) -> untyped

  def self.cp: (*untyped args, **untyped options) -> untyped

  def self.cp_r: (*untyped args, **untyped options) -> untyped

  def self.getwd: () -> untyped

  def self.identical?: (untyped a, untyped b) -> untyped

  def self.install: (*untyped args, **untyped options) -> untyped

  def self.link: (*untyped args, **untyped options) -> untyped

  def self.ln: (*untyped args, **untyped options) -> untyped

  def self.ln_s: (*untyped args, **untyped options) -> untyped

  def self.ln_sf: (*untyped args, **untyped options) -> untyped

  def self.makedirs: (*untyped args, **untyped options) -> untyped

  def self.mkdir: (*untyped args, **untyped options) -> untyped

  def self.mkdir_p: (*untyped args, **untyped options) -> untyped

  def self.mkpath: (*untyped args, **untyped options) -> untyped

  def self.move: (*untyped args, **untyped options) -> untyped

  def self.mv: (*untyped args, **untyped options) -> untyped

  def self.pwd: () -> untyped

  def self.remove: (*untyped args, **untyped options) -> untyped

  def self.remove_dir: (untyped path, ?untyped force) -> untyped

  def self.remove_entry: (untyped path, ?untyped force) -> untyped

  def self.remove_entry_secure: (untyped path, ?untyped force) -> untyped

  def self.remove_file: (untyped path, ?untyped force) -> untyped

  def self.rm: (*untyped args, **untyped options) -> untyped

  def self.rm_f: (*untyped args, **untyped options) -> untyped

  def self.rm_r: (*untyped args, **untyped options) -> untyped

  def self.rm_rf: (*untyped args, **untyped options) -> untyped

  def self.rmdir: (*untyped args, **untyped options) -> untyped

  def self.rmtree: (*untyped args, **untyped options) -> untyped

  def self.safe_unlink: (*untyped args, **untyped options) -> untyped

  def self.symlink: (*untyped args, **untyped options) -> untyped

  def self.touch: (*untyped args, **untyped options) -> untyped

  def self.uptodate?: (untyped new, untyped old_list) -> untyped
end

class Bundler::GemHelper
  def allowed_push_host: () -> untyped

  def already_tagged?: () -> untyped

  def base: () -> untyped

  def build_checksum: (?untyped built_gem_path) -> untyped

  def build_gem: () -> untyped

  def built_gem_path: () -> untyped

  def clean?: () -> untyped

  def committed?: () -> untyped

  def current_branch: () -> untyped

  def default_remote: () -> untyped

  def gem_command: () -> untyped

  def gem_key: () -> untyped

  def gem_push?: () -> untyped

  def gem_push_host: () -> untyped

  def gemspec: () -> untyped

  def git_push: (?untyped remote) -> untyped

  def guard_clean: () -> untyped

  def initialize: (?untyped base, ?untyped name) -> void

  def install: () -> untyped

  def install_gem: (?untyped built_gem_path, ?untyped local) -> untyped

  def name: () -> untyped

  def rubygem_push: (untyped path) -> untyped

  def sh: (untyped cmd) { () -> untyped } -> untyped

  def sh_with_input: (untyped cmd) -> untyped

  def sh_with_status: (untyped cmd) { () -> untyped } -> untyped

  def spec_path: () -> untyped

  def tag_prefix=: (untyped tag_prefix) -> untyped

  def tag_version: () -> untyped

  def version: () -> untyped

  def version_tag: () -> untyped

  def self.instance: () -> untyped

  def self.instance=: (untyped instance) -> untyped

  def self.install_tasks: (?untyped opts) -> untyped

  def self.tag_prefix=: (untyped tag_prefix) -> untyped

  def self.gemspec: () { () -> untyped } -> untyped
end

module Bundler::GemHelpers
  def self.generic: (untyped p) -> untyped

  def self.generic_local_platform: () -> untyped

  def self.platform_specificity_match: (untyped spec_platform, untyped user_platform) -> untyped

  def self.select_best_platform_match: (untyped specs, untyped platform) -> untyped
end

Bundler::GemHelpers::GENERICS: untyped

Bundler::GemHelpers::GENERIC_CACHE: untyped

class Bundler::GemHelpers::PlatformMatch < Struct
  def <=>: (untyped other) -> untyped

  def cpu_match: () -> untyped

  def cpu_match=: (untyped _) -> untyped

  def os_match: () -> untyped

  def os_match=: (untyped _) -> untyped

  def platform_version_match: () -> untyped

  def platform_version_match=: (untyped _) -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.cpu_match: (untyped spec_platform, untyped user_platform) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped

  def self.os_match: (untyped spec_platform, untyped user_platform) -> untyped

  def self.platform_version_match: (untyped spec_platform, untyped user_platform) -> untyped
end

Bundler::GemHelpers::PlatformMatch::Elem: untyped

Bundler::GemHelpers::PlatformMatch::EXACT_MATCH: untyped

Bundler::GemHelpers::PlatformMatch::WORST_MATCH: untyped

class Bundler::GemNotFound < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::GemRequireError < Bundler::BundlerError
  def initialize: (untyped orig_exception, untyped msg) -> void

  def orig_exception: () -> untyped

  def status_code: () -> untyped
end

class Bundler::GemfileError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::GemfileEvalError < Bundler::GemfileError
end

class Bundler::GemfileLockNotFound < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::GemfileNotFound < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::GemspecError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::GenericSystemCallError < Bundler::BundlerError
  def initialize: (untyped underlying_error, untyped message) -> void

  def status_code: () -> untyped

  def underlying_error: () -> untyped
end

class Bundler::GitError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::HTTPError < Bundler::BundlerError
  def filter_uri: (untyped uri) -> untyped

  def status_code: () -> untyped
end

# Handles all the fetching with the rubygems server
class Bundler::Fetcher
end

# This error is raised if HTTP authentication is required, but not provided.
class Bundler::Fetcher::AuthenticationRequiredError < Bundler::HTTPError
end

# This error is raised if HTTP authentication is provided, but incorrect.
class Bundler::Fetcher::BadAuthenticationError < Bundler::HTTPError
end

# This is the error raised if
# [`OpenSSL`](https://docs.ruby-lang.org/en/2.7.0/OpenSSL.html) fails the cert
# verification
class Bundler::Fetcher::CertificateFailureError < Bundler::HTTPError
end

# This error is raised if the API returns a 413 (only printed in verbose)
class Bundler::Fetcher::FallbackError < Bundler::HTTPError
end

# This error is raised when it looks like the network is down
class Bundler::Fetcher::NetworkDownError < Bundler::HTTPError
end

# This is the error raised when a source is HTTPS and
# [`OpenSSL`](https://docs.ruby-lang.org/en/2.7.0/OpenSSL.html) didn't load
class Bundler::Fetcher::SSLError < Bundler::HTTPError
end

class Bundler::Index[out Elem]
  include ::Enumerable

  def <<: (untyped spec) -> untyped

  def ==: (untyped other) -> untyped

  def []: (untyped query, ?untyped base) -> untyped

  def add_source: (untyped index) -> untyped

  def all_specs: () -> untyped

  def dependencies_eql?: (untyped spec, untyped other_spec) -> untyped

  def dependency_names: () -> untyped

  def each: () { () -> untyped } -> untyped

  def empty?: () -> untyped

  def initialize: () -> void

  def inspect: () -> untyped

  def local_search: (untyped query, ?untyped base) -> untyped

  def search: (untyped query, ?untyped base) -> untyped

  def search_all: (untyped name) -> untyped

  def size: () -> untyped

  def sort_specs: (untyped specs) -> untyped

  def sources: () -> untyped

  def spec_names: () -> untyped

  def specs: () -> untyped

  # returns a list of the dependencies
  def unmet_dependency_names: () -> untyped

  def unsorted_search: (untyped query, untyped base) -> untyped

  def use: (untyped other, ?untyped override_dupes) -> untyped

  def self.build: () -> untyped

  def self.sort_specs: (untyped specs) -> untyped
end

Bundler::Index::EMPTY_SEARCH: untyped

Bundler::Index::NULL: untyped

Bundler::Index::RUBY: untyped

class Bundler::InstallError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::InstallHookError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::InvalidOption < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::LazySpecification
  include ::Bundler::MatchPlatform

  include ::Bundler::GemHelpers

  def ==: (untyped other) -> untyped

  def __materialize__: () -> untyped

  def dependencies: () -> untyped

  def full_name: () -> untyped

  def git_version: () -> untyped

  def identifier: () -> untyped

  def initialize: (untyped name, untyped version, untyped platform, ?untyped source) -> void

  def name: () -> String

  def platform: () -> untyped

  def remote: () -> untyped

  def remote=: (untyped remote) -> untyped

  def respond_to?: (*untyped args) -> untyped

  def satisfies?: (untyped dependency) -> untyped

  def source: () -> untyped

  def source=: (untyped source) -> untyped

  def to_lock: () -> untyped

  def to_s: () -> untyped

  def version: () -> String
end

class Bundler::LazySpecification::Identifier < Struct
  include ::Comparable

  extend ::T::Generic

  def <=>: (untyped other) -> untyped

  def dependencies: () -> untyped

  def dependencies=: (untyped _) -> untyped

  def name: () -> untyped

  def name=: (untyped _) -> untyped

  def platform: () -> untyped

  def platform=: (untyped _) -> untyped

  def platform_string: () -> untyped

  def source: () -> untyped

  def source=: (untyped _) -> untyped

  def version: () -> untyped

  def version=: (untyped _) -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::LazySpecification::Identifier::Elem: untyped

class Bundler::LockfileError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::LockfileParser
  def bundler_version: () -> untyped

  def dependencies: () -> Hash[String, Bundler::Dependency]

  def initialize: (untyped lockfile) -> void

  def platforms: () -> untyped

  def ruby_version: () -> untyped

  def sources: () -> untyped

  def specs: () -> ::Array[::Bundler::LazySpecification]

  def warn_for_outdated_bundler_version: () -> untyped

  def self.sections_in_lockfile: (untyped lockfile_contents) -> untyped

  def self.sections_to_ignore: (?untyped base_version) -> untyped

  def self.unknown_sections_in_lockfile: (untyped lockfile_contents) -> untyped
end

Bundler::LockfileParser::BUNDLED: untyped

Bundler::LockfileParser::DEPENDENCIES: untyped

Bundler::LockfileParser::ENVIRONMENT_VERSION_SECTIONS: untyped

Bundler::LockfileParser::GEM: untyped

Bundler::LockfileParser::GIT: untyped

Bundler::LockfileParser::KNOWN_SECTIONS: untyped

Bundler::LockfileParser::NAME_VERSION: untyped

Bundler::LockfileParser::OPTIONS: untyped

Bundler::LockfileParser::PATH: untyped

Bundler::LockfileParser::PLATFORMS: untyped

Bundler::LockfileParser::PLUGIN: untyped

Bundler::LockfileParser::RUBY: untyped

Bundler::LockfileParser::SECTIONS_BY_VERSION_INTRODUCED: untyped

Bundler::LockfileParser::SOURCE: untyped

Bundler::LockfileParser::SPECS: untyped

Bundler::LockfileParser::TYPES: untyped

class Bundler::MarshalError < StandardError
end

module Bundler::MatchPlatform
  include ::Bundler::GemHelpers

  def match_platform: (untyped p) -> untyped

  def self.platforms_match?: (untyped gemspec_platform, untyped local_platform) -> untyped
end

# [`Bundler::Molinillo`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo.html)
# is a generic dependency resolution algorithm.
module Bundler::Molinillo
end

Bundler::Molinillo::VERSION: untyped

# An error caused by attempting to fulfil a dependency that was circular
#
# @note This exception will be thrown iff a {Vertex} is added to a
#
# ```
# {DependencyGraph} that has a {DependencyGraph::Vertex#path_to?} an
# existing {DependencyGraph::Vertex}
# ```
class Bundler::Molinillo::CircularDependencyError < Bundler::Molinillo::ResolverError
  # [`Set`](https://docs.ruby-lang.org/en/2.7.0/Set.html)<Object>
  # :   the dependencies responsible for causing the error
  def dependencies: () -> untyped

  def initialize: (untyped vertices) -> void
end

# Hacks needed for old Ruby versions.
module Bundler::Molinillo::Compatibility
  def self.flat_map: (untyped enum) { () -> untyped } -> untyped
end

# @!visibility private
module Bundler::Molinillo::Delegates
end

# [`Delegates`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/Delegates.html)
# all {Bundler::Molinillo::ResolutionState} methods to a `#state` property.
module Bundler::Molinillo::Delegates::ResolutionState
  # (see Bundler::Molinillo::ResolutionState#activated)
  def activated: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#conflicts)
  def conflicts: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#depth)
  def depth: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#name)
  def name: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#possibilities)
  def possibilities: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#requirement)
  def requirement: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#requirements)
  def requirements: () -> untyped

  # (see Bundler::Molinillo::ResolutionState#unused\_unwind\_options)
  def unused_unwind_options: () -> untyped
end

# [`Delegates`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/Delegates.html)
# all {Bundler::Molinillo::SpecificationProvider} methods to a
# `#specification\_provider` property.
module Bundler::Molinillo::Delegates::SpecificationProvider
  def allow_missing?: (untyped dependency) -> untyped

  def dependencies_for: (untyped specification) -> untyped

  def name_for: (untyped dependency) -> untyped

  # (see
  # [`Bundler::Molinillo::SpecificationProvider#name_for_explicit_dependency_source`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/SpecificationProvider.html#method-i-name_for_explicit_dependency_source))
  def name_for_explicit_dependency_source: () -> untyped

  # (see
  # [`Bundler::Molinillo::SpecificationProvider#name_for_locking_dependency_source`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/SpecificationProvider.html#method-i-name_for_locking_dependency_source))
  def name_for_locking_dependency_source: () -> untyped

  def requirement_satisfied_by?: (untyped requirement, untyped activated, untyped spec) -> untyped

  def search_for: (untyped dependency) -> untyped

  def sort_dependencies: (untyped dependencies, untyped activated, untyped conflicts) -> untyped
end

# A directed acyclic graph that is tuned to hold named dependencies
class Bundler::Molinillo::DependencyGraph[out Elem]
  include ::TSort

  include ::Enumerable

  def ==: (untyped other) -> untyped

  def add_child_vertex: (untyped name, untyped payload, untyped parent_names, untyped requirement) -> untyped

  def add_edge: (untyped origin, untyped destination, untyped requirement) -> untyped

  def add_vertex: (untyped name, untyped payload, ?untyped root) -> untyped

  def delete_edge: (untyped edge) -> untyped

  def detach_vertex_named: (untyped name) -> untyped

  def each: () { () -> untyped } -> untyped

  def initialize: () -> void

  # @return [String] a string suitable for debugging
  def inspect: () -> untyped

  # @return [Log] the op log for this graph
  def log: () -> untyped

  def rewind_to: (untyped tag) -> untyped

  def root_vertex_named: (untyped name) -> untyped

  def set_payload: (untyped name, untyped payload) -> untyped

  def tag: (untyped tag) -> untyped

  def to_dot: (?untyped options) -> untyped

  def tsort_each_child: (untyped vertex) { () -> untyped } -> untyped

  # @!visibility private
  #
  # Alias for:
  # [`each`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/DependencyGraph.html#method-i-each)
  def tsort_each_node: () -> untyped

  def vertex_named: (untyped name) -> untyped

  # @return [{String => Vertex}] the vertices of the dependency graph, keyed
  #
  # ```
  # by {Vertex#name}
  # ```
  def vertices: () -> untyped

  def self.tsort: (untyped vertices) -> untyped
end

# An action that modifies a {DependencyGraph} that is reversible. @abstract
class Bundler::Molinillo::DependencyGraph::Action
  def down: (untyped graph) -> untyped

  # @return [Action,Nil] The next action
  def next: () -> untyped

  def next=: (untyped _) -> untyped

  # @return [Action,Nil] The previous action
  def previous: () -> untyped

  def previous=: (untyped previous) -> untyped

  def up: (untyped graph) -> untyped

  # @return [Symbol] The name of the action.
  def self.action_name: () -> untyped
end

# @!visibility private (see
# [`DependencyGraph#add_edge_no_circular`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/DependencyGraph.html#method-i-add_edge_no_circular))
class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular < Bundler::Molinillo::DependencyGraph::Action
  # @return [String] the name of the destination of the edge
  def destination: () -> untyped

  def down: (untyped graph) -> untyped

  def initialize: (untyped origin, untyped destination, untyped requirement) -> void

  def make_edge: (untyped graph) -> untyped

  # @return [String] the name of the origin of the edge
  def origin: () -> untyped

  # @return [Object] the requirement that the edge represents
  def requirement: () -> untyped

  def up: (untyped graph) -> untyped

  # (see Action.action\_name)
  def self.action_name: () -> untyped
end

class Bundler::Molinillo::DependencyGraph::AddVertex < Bundler::Molinillo::DependencyGraph::Action
  def down: (untyped graph) -> untyped

  def initialize: (untyped name, untyped payload, untyped root) -> void

  def name: () -> untyped

  def payload: () -> untyped

  def root: () -> untyped

  def up: (untyped graph) -> untyped

  def self.action_name: () -> untyped
end

# @!visibility private (see
# [`DependencyGraph#delete_edge`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/DependencyGraph.html#method-i-delete_edge))
class Bundler::Molinillo::DependencyGraph::DeleteEdge < Bundler::Molinillo::DependencyGraph::Action
  # @return [String] the name of the destination of the edge
  def destination_name: () -> untyped

  def down: (untyped graph) -> untyped

  def initialize: (untyped origin_name, untyped destination_name, untyped requirement) -> void

  def make_edge: (untyped graph) -> untyped

  # @return [String] the name of the origin of the edge
  def origin_name: () -> untyped

  # @return [Object] the requirement that the edge represents
  def requirement: () -> untyped

  def up: (untyped graph) -> untyped

  # (see Action.action\_name)
  def self.action_name: () -> untyped
end

# @!visibility private @see
# [`DependencyGraph#detach_vertex_named`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/DependencyGraph.html#method-i-detach_vertex_named)
class Bundler::Molinillo::DependencyGraph::DetachVertexNamed < Bundler::Molinillo::DependencyGraph::Action
  def down: (untyped graph) -> untyped

  def initialize: (untyped name) -> void

  # @return [String] the name of the vertex to detach
  def name: () -> untyped

  def up: (untyped graph) -> untyped

  # (see Action#name)
  def self.action_name: () -> untyped
end

# A directed edge of a {DependencyGraph} @attr [Vertex] origin The origin of the
# directed edge @attr [Vertex] destination The destination of the directed edge
# @attr [Object] requirement The requirement the directed edge represents
class Bundler::Molinillo::DependencyGraph::Edge < Struct
  def destination: () -> untyped

  def destination=: (untyped _) -> untyped

  def origin: () -> untyped

  def origin=: (untyped _) -> untyped

  def requirement: () -> untyped

  def requirement=: (untyped _) -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::Molinillo::DependencyGraph::Edge::Elem: untyped

# A log for dependency graph actions
class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable

  def add_edge_no_circular: (untyped graph, untyped origin, untyped destination, untyped requirement) -> untyped

  def add_vertex: (untyped graph, untyped name, untyped payload, untyped root) -> untyped

  def delete_edge: (untyped graph, untyped origin_name, untyped destination_name, untyped requirement) -> untyped

  def detach_vertex_named: (untyped graph, untyped name) -> untyped

  def each: () { () -> untyped } -> untyped

  def initialize: () -> void

  def pop!: (untyped graph) -> untyped

  # @!visibility private Enumerates each action in the log in reverse order
  # @yield [Action]
  def reverse_each: () -> untyped

  def rewind_to: (untyped graph, untyped tag) -> untyped

  def set_payload: (untyped graph, untyped name, untyped payload) -> untyped

  def tag: (untyped graph, untyped tag) -> untyped
end

Bundler::Molinillo::DependencyGraph::Log::Elem: untyped

class Bundler::Molinillo::DependencyGraph::SetPayload < Bundler::Molinillo::DependencyGraph::Action
  def down: (untyped graph) -> untyped

  def initialize: (untyped name, untyped payload) -> void

  def name: () -> untyped

  def payload: () -> untyped

  def up: (untyped graph) -> untyped

  def self.action_name: () -> untyped
end

# @!visibility private @see
# [`DependencyGraph#tag`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo/DependencyGraph.html#method-i-tag)
class Bundler::Molinillo::DependencyGraph::Tag < Bundler::Molinillo::DependencyGraph::Action
  def down: (untyped _graph) -> untyped

  def initialize: (untyped tag) -> void

  # @return [Object] An opaque tag
  def tag: () -> untyped

  def up: (untyped _graph) -> untyped

  # (see Action.action\_name)
  def self.action_name: () -> untyped
end

# A vertex in a {DependencyGraph} that encapsulates a {#name} and a {#payload}
class Bundler::Molinillo::DependencyGraph::Vertex
  def ==: (untyped other) -> untyped

  def _path_to?: (untyped other, ?untyped visited) -> untyped

  def ancestor?: (untyped other) -> untyped

  def descendent?: (untyped other) -> untyped

  def eql?: (untyped other) -> untyped

  # @return [Array<Object>] the explicit requirements that required
  #
  # ```ruby
  # this vertex
  # ```
  def explicit_requirements: () -> untyped

  # @return [Fixnum] a hash for the vertex based upon its {#name}
  def hash: () -> untyped

  # @return [Array<Edge>] the edges of {#graph} that have `self` as their
  #
  # ```
  # {Edge#destination}
  # ```
  def incoming_edges: () -> untyped

  def incoming_edges=: (untyped incoming_edges) -> untyped

  def initialize: (untyped name, untyped payload) -> void

  # @return [String] a string suitable for debugging
  def inspect: () -> untyped

  def is_reachable_from?: (untyped other) -> untyped

  # @return [String] the name of the vertex
  def name: () -> untyped

  def name=: (untyped name) -> untyped

  # @return [Array<Edge>] the edges of {#graph} that have `self` as their
  #
  # ```
  # {Edge#origin}
  # ```
  def outgoing_edges: () -> untyped

  def outgoing_edges=: (untyped outgoing_edges) -> untyped

  def path_to?: (untyped other) -> untyped

  # @return [Object] the payload the vertex holds
  def payload: () -> untyped

  def payload=: (untyped payload) -> untyped

  # @return [Array<Vertex>] the vertices of {#graph} that have an edge with
  #
  # ```
  # `self` as their {Edge#destination}
  # ```
  def predecessors: () -> untyped

  # @return [Set<Vertex>] the vertices of {#graph} where `self` is a
  #
  # ```
  # {#descendent?}
  # ```
  def recursive_predecessors: () -> untyped

  # @return [Set<Vertex>] the vertices of {#graph} where `self` is an
  #
  # ```
  # {#ancestor?}
  # ```
  def recursive_successors: () -> untyped

  # @return [Array<Object>] all of the requirements that required
  #
  # ```ruby
  # this vertex
  # ```
  def requirements: () -> untyped

  # @return [Boolean] whether the vertex is considered a root vertex
  def root: () -> untyped

  def root=: (untyped root) -> untyped

  # @return [Boolean] whether the vertex is considered a root vertex
  def root?: () -> untyped

  def shallow_eql?: (untyped other) -> untyped

  # @return [Array<Vertex>] the vertices of {#graph} that have an edge with
  #
  # ```
  # `self` as their {Edge#origin}
  # ```
  def successors: () -> untyped
end

# A state that encapsulates a set of {#requirements} with an {Array} of
# possibilities
class Bundler::Molinillo::DependencyState < Bundler::Molinillo::ResolutionState
  # Removes a possibility from `self` @return [PossibilityState] a state with a
  # single possibility,
  #
  # ```ruby
  # the possibility that was removed from `self`
  # ```
  def pop_possibility_state: () -> untyped
end

Bundler::Molinillo::DependencyState::Elem: untyped

# An error caused by searching for a dependency that is completely unknown, i.e.
# has no versions available whatsoever.
class Bundler::Molinillo::NoSuchDependencyError < Bundler::Molinillo::ResolverError
  # @return [Object] the dependency that could not be found
  def dependency: () -> untyped

  def dependency=: (untyped dependency) -> untyped

  def initialize: (untyped dependency, ?untyped required_by) -> void

  # The error message for the missing dependency, including the specifications
  # that had this dependency.
  def message: () -> untyped

  # @return [Array<Object>] the specifications that depended upon {#dependency}
  def required_by: () -> untyped

  def required_by=: (untyped required_by) -> untyped
end

# A state that encapsulates a single possibility to fulfill the given
# {#requirement}
class Bundler::Molinillo::PossibilityState < Bundler::Molinillo::ResolutionState
end

Bundler::Molinillo::PossibilityState::Elem: untyped

class Bundler::Molinillo::ResolutionState < Struct
  def activated: () -> untyped

  def activated=: (untyped _) -> untyped

  def conflicts: () -> untyped

  def conflicts=: (untyped _) -> untyped

  def depth: () -> untyped

  def depth=: (untyped _) -> untyped

  def name: () -> untyped

  def name=: (untyped _) -> untyped

  def possibilities: () -> untyped

  def possibilities=: (untyped _) -> untyped

  def requirement: () -> untyped

  def requirement=: (untyped _) -> untyped

  def requirements: () -> untyped

  def requirements=: (untyped _) -> untyped

  def unused_unwind_options: () -> untyped

  def unused_unwind_options=: (untyped _) -> untyped

  def self.[]: (*untyped _) -> untyped

  # Returns an empty resolution state @return [ResolutionState] an empty state
  def self.empty: () -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::Molinillo::ResolutionState::Elem: untyped

# This class encapsulates a dependency resolver. The resolver is responsible for
# determining which set of dependencies to activate, with feedback from the
# {#specification\_provider}
class Bundler::Molinillo::Resolver
  def initialize: (untyped specification_provider, untyped resolver_ui) -> void

  def resolve: (untyped requested, ?untyped base) -> untyped

  # @return [UI] the UI module used to communicate back to the user
  #
  # ```ruby
  # during the resolution process
  # ```
  def resolver_ui: () -> untyped

  # @return [SpecificationProvider] the specification provider used
  #
  # ```
  # in the resolution process
  # ```
  def specification_provider: () -> untyped
end

# A specific resolution from a given {Resolver}
class Bundler::Molinillo::Resolver::Resolution
  include ::Bundler::Molinillo::Delegates::SpecificationProvider

  include ::Bundler::Molinillo::Delegates::ResolutionState

  # @return [DependencyGraph] the base dependency graph to which
  #
  # ```ruby
  # dependencies should be 'locked'
  # ```
  def base: () -> untyped

  def initialize: (untyped specification_provider, untyped resolver_ui, untyped requested, untyped base) -> void

  def iteration_rate=: (untyped iteration_rate) -> untyped

  # @return [Array] the dependencies that were explicitly required
  def original_requested: () -> untyped

  # Resolves the {#original\_requested} dependencies into a full dependency
  #
  # ```ruby
  # graph
  # ```
  #
  # @raise [ResolverError] if successful resolution is impossible @return
  # [DependencyGraph] the dependency graph of successfully resolved
  #
  # ```ruby
  # dependencies
  # ```
  def resolve: () -> untyped

  # @return [UI] the UI that knows how to communicate feedback about the
  #
  # ```ruby
  # resolution process back to the user
  # ```
  def resolver_ui: () -> untyped

  # @return [SpecificationProvider] the provider that knows about
  #
  # ```
  # dependencies, requirements, specifications, versions, etc.
  # ```
  def specification_provider: () -> untyped

  def started_at=: (untyped started_at) -> untyped

  def states=: (untyped states) -> untyped
end

class Bundler::Molinillo::Resolver::Resolution::Conflict < Struct
  def activated_by_name: () -> untyped

  def activated_by_name=: (untyped _) -> untyped

  def existing: () -> untyped

  def existing=: (untyped _) -> untyped

  def locked_requirement: () -> untyped

  def locked_requirement=: (untyped _) -> untyped

  # @return [Object] a spec that was unable to be activated due to a conflict
  def possibility: () -> untyped

  def possibility_set: () -> untyped

  def possibility_set=: (untyped _) -> untyped

  def requirement: () -> untyped

  def requirement=: (untyped _) -> untyped

  def requirement_trees: () -> untyped

  def requirement_trees=: (untyped _) -> untyped

  def requirements: () -> untyped

  def requirements=: (untyped _) -> untyped

  def underlying_error: () -> untyped

  def underlying_error=: (untyped _) -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::Molinillo::Resolver::Resolution::Conflict::Elem: untyped

class Bundler::Molinillo::Resolver::Resolution::PossibilitySet < Struct
  def dependencies: () -> untyped

  def dependencies=: (untyped _) -> untyped

  # @return [Object] most up-to-date dependency in the possibility set
  def latest_version: () -> untyped

  def possibilities: () -> untyped

  def possibilities=: (untyped _) -> untyped

  # [`String`](https://docs.ruby-lang.org/en/2.7.0/String.html) representation
  # of the possibility set, for debugging
  def to_s: () -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::Molinillo::Resolver::Resolution::PossibilitySet::Elem: untyped

class Bundler::Molinillo::Resolver::Resolution::UnwindDetails < Struct
  include ::Comparable

  def <=>: (untyped other) -> untyped

  # @return [Array] array of all the requirements that led to the need for
  #
  # ```ruby
  # this unwind
  # ```
  def all_requirements: () -> untyped

  def conflicting_requirements: () -> untyped

  def conflicting_requirements=: (untyped _) -> untyped

  def requirement_tree: () -> untyped

  def requirement_tree=: (untyped _) -> untyped

  def requirement_trees: () -> untyped

  def requirement_trees=: (untyped _) -> untyped

  def requirements_unwound_to_instead: () -> untyped

  def requirements_unwound_to_instead=: (untyped _) -> untyped

  # @return [Integer] index of state requirement in reversed requirement tree
  #
  # ```ruby
  # (the conflicting requirement itself will be at position 0)
  # ```
  def reversed_requirement_tree_index: () -> untyped

  def state_index: () -> untyped

  def state_index=: (untyped _) -> untyped

  def state_requirement: () -> untyped

  def state_requirement=: (untyped _) -> untyped

  # @return [Array] array of sub-dependencies to avoid when choosing a
  #
  # ```
  # new possibility for the state we've unwound to. Only relevant for
  # non-primary unwinds
  # ```
  def sub_dependencies_to_avoid: () -> untyped

  # @return [Boolean] where the requirement of the state we're unwinding
  #
  # ```
  # to directly caused the conflict. Note: in this case, it is
  # impossible for the state we're unwinding to to be a parent of
  # any of the other conflicting requirements (or we would have
  # circularity)
  # ```
  def unwinding_to_primary_requirement?: () -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::Molinillo::Resolver::Resolution::UnwindDetails::Elem: untyped

# An error that occurred during the resolution process
class Bundler::Molinillo::ResolverError < StandardError
end

# Provides information about specifications and dependencies to the resolver,
# allowing the {Resolver} class to remain generic while still providing power
# and flexibility.
#
# This module contains the methods that users of
# [`Bundler::Molinillo`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Molinillo.html)
# must to implement, using knowledge of their own model classes.
module Bundler::Molinillo::SpecificationProvider
  def allow_missing?: (untyped dependency) -> untyped

  def dependencies_for: (untyped specification) -> untyped

  def name_for: (untyped dependency) -> untyped

  # @return [String] the name of the source of explicit dependencies, i.e.
  #
  # ```
  # those passed to {Resolver#resolve} directly.
  # ```
  def name_for_explicit_dependency_source: () -> untyped

  # @return [String] the name of the source of 'locked' dependencies, i.e.
  #
  # ```
  # those passed to {Resolver#resolve} directly as the `base`
  # ```
  def name_for_locking_dependency_source: () -> untyped

  def requirement_satisfied_by?: (untyped requirement, untyped activated, untyped spec) -> untyped

  def search_for: (untyped dependency) -> untyped

  def sort_dependencies: (untyped dependencies, untyped activated, untyped conflicts) -> untyped
end

# Conveys information about the resolution process to a user.
module Bundler::Molinillo::UI
  # Called after resolution ends (either successfully or with an error). By
  # default, prints a newline.
  #
  # @return [void]
  def after_resolution: () -> untyped

  # Called before resolution begins.
  #
  # @return [void]
  def before_resolution: () -> untyped

  def debug: (?untyped depth) -> untyped

  # Whether or not debug messages should be printed. By default, whether or not
  # the `MOLINILLO\_DEBUG` environment variable is set.
  #
  # @return [Boolean]
  def debug?: () -> untyped

  # Called roughly every {#progress\_rate}, this method should convey progress
  # to the user.
  #
  # @return [void]
  def indicate_progress: () -> untyped

  # The {IO} object that should be used to print output. `STDOUT`, by default.
  #
  # @return [IO]
  def output: () -> untyped

  # How often progress should be conveyed to the user via {#indicate\_progress},
  # in seconds. A third of a second, by default.
  #
  # @return [Float]
  def progress_rate: () -> untyped
end

# An error caused by conflicts in version
class Bundler::Molinillo::VersionConflict < Bundler::Molinillo::ResolverError
  include ::Bundler::Molinillo::Delegates::SpecificationProvider

  # @return [{String => Resolution::Conflict}] the conflicts that caused
  #
  # ```ruby
  # resolution to fail
  # ```
  def conflicts: () -> untyped

  def initialize: (untyped conflicts, untyped specification_provider) -> void

  def message_with_trees: (?untyped opts) -> untyped

  # @return [SpecificationProvider] the specification provider used during
  #
  # ```ruby
  # resolution
  # ```
  def specification_provider: () -> untyped
end

class Bundler::NoSpaceOnDeviceError < Bundler::PermissionError
  def message: () -> untyped

  def status_code: () -> untyped
end

class Bundler::OperationNotSupportedError < Bundler::PermissionError
  def message: () -> untyped

  def status_code: () -> untyped
end

class Bundler::PathError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::PermissionError < Bundler::BundlerError
  def action: () -> untyped

  def initialize: (untyped path, ?untyped permission_type) -> void

  def message: () -> untyped

  def status_code: () -> untyped
end

# This is the interfacing class represents the API that we intend to provide the
# plugins to use.
#
# For plugins to be independent of the
# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) internals they
# shall limit their interactions to methods of this class only. This will save
# them from breaking when some internal change.
#
# Currently we are delegating the methods defined in
# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) class to itself.
# So, this class acts as a buffer.
#
# If there is some change in the
# [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) class that is
# incompatible to its previous behavior or if otherwise desired, we can
# reimplement(or implement) the method to preserve compatibility.
#
# To use this, either the class can inherit this class or use it directly. For
# example of both types of use, refer the file `spec/plugins/command.rb`
#
# To use it without inheriting, you will have to create an object of this to use
# the functions (except for declaration functions like command, source, and
# hooks).
# Manages which plugins are installed and their sources. This also is supposed
# to map which plugin does what (currently the features are not implemented so
# this class is now a stub class).
# Handles the installation of plugin in appropriate directories.
#
# This class is supposed to be wrapper over the existing gem installation infra
# but currently it itself handles everything as the Source's subclasses (e.g.
# Source::RubyGems) are heavily dependent on the Gemfile.
# SourceList object to be used while parsing the Gemfile, setting the
# approptiate options to be used with Source classes for plugin installation
module Bundler::Plugin
  def self.add_command: (untyped command, untyped cls) -> untyped

  def self.add_hook: (untyped event) { () -> untyped } -> untyped

  def self.add_source: (untyped source, untyped cls) -> untyped

  def self.cache: () -> untyped

  def self.command?: (untyped command) -> untyped

  def self.exec_command: (untyped command, untyped args) -> untyped

  def self.gemfile_install: (?untyped gemfile) { () -> untyped } -> untyped

  def self.global_root: () -> untyped

  def self.hook: (untyped event, *untyped args) { () -> untyped } -> untyped

  def self.index: () -> untyped

  def self.install: (untyped names, untyped options) -> untyped

  def self.installed?: (untyped plugin) -> untyped

  def self.local_root: () -> untyped

  def self.reset!: () -> untyped

  def self.root: () -> untyped

  def self.source: (untyped name) -> untyped

  def self.source?: (untyped name) -> untyped

  def self.source_from_lock: (untyped locked_opts) -> untyped
end

Bundler::Plugin::PLUGIN_FILE_NAME: untyped

class Bundler::Plugin::API
  # The cache dir to be used by the plugins for storage
  #
  # @return [Pathname] path of the cache dir
  def cache_dir: () -> untyped

  def method_missing: (untyped name, *untyped args) { () -> untyped } -> untyped

  def tmp: (*untyped names) -> untyped

  def self.command: (untyped command, ?untyped cls) -> untyped

  def self.hook: (untyped event) { () -> untyped } -> untyped

  def self.source: (untyped source, ?untyped cls) -> untyped
end

# Dsl to parse the Gemfile looking for plugins to install
class Bundler::Plugin::DSL < Bundler::Dsl
  def _gem: (untyped name, *untyped args) -> untyped

  # This lists the plugins that was added automatically and not specified by the
  # user.
  #
  # When we encounter :type attribute with a source block, we add a plugin by
  # name bundler-source-<type> to list of plugins to be installed.
  #
  # These plugins are optional and are not installed when there is conflict with
  # any other plugin.
  def inferred_plugins: () -> untyped

  def plugin: (untyped name, *untyped args) -> untyped
end

module Bundler::Plugin::Events
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::MalformattedPlugin < Bundler::PluginError
end

class Bundler::Plugin::UndefinedCommandError < Bundler::PluginError
end

class Bundler::Plugin::UnknownSourceError < Bundler::PluginError
end

class Bundler::Plugin::DSL::PluginGemfileError < Bundler::PluginError
end

class Bundler::PluginError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::ProductionError < Bundler::BundlerError
  def status_code: () -> untyped
end

# Represents a lazily loaded gem specification, where the full specification is
# on the source server in rubygems' "quick" index. The proxy object is to be
# seeded with what we're given from the source's abbreviated index - the full
# specification will only be fetched when necessary.
class Bundler::RemoteSpecification
  include ::Comparable

  include ::Bundler::MatchPlatform

  include ::Bundler::GemHelpers

  def <=>: (untyped other) -> untyped

  def __swap__: (untyped spec) -> untyped

  def dependencies: () -> untyped

  def dependencies=: (untyped dependencies) -> untyped

  # Needed before installs, since the arch matters then and quick specs don't
  # bother to include the arch in the platform string
  def fetch_platform: () -> untyped

  def full_name: () -> untyped

  def git_version: () -> untyped

  def initialize: (untyped name, untyped version, untyped platform, untyped spec_fetcher) -> void

  def name: () -> String

  def platform: () -> untyped

  def remote: () -> untyped

  def remote=: (untyped remote) -> untyped

  def respond_to?: (untyped method, ?untyped include_all) -> untyped

  # Create a delegate used for sorting. This strategy is copied from RubyGems
  # 2.23 and ensures that Bundler's specifications can be compared and sorted
  # with RubyGems' own specifications.
  #
  # @see #<=> @see
  # [`Gem::Specification#sort_obj`](https://docs.ruby-lang.org/en/2.7.0/Gem/Specification.html#method-i-sort_obj)
  #
  # @return [Array] an object you can use to compare and sort this
  #
  # ```ruby
  # specification against other specifications
  # ```
  def sort_obj: () -> untyped

  def source: () -> untyped

  def source=: (untyped source) -> untyped

  def to_s: () -> untyped

  def version: () -> String
end

class Bundler::Resolver
  include ::Bundler::Molinillo::SpecificationProvider

  include ::Bundler::Molinillo::UI

  def after_resolution: () -> untyped

  def before_resolution: () -> untyped

  def debug: (?untyped depth) -> untyped

  def debug?: () -> untyped

  def dependencies_for: (untyped specification) -> untyped

  def index_for: (untyped dependency) -> untyped

  def indicate_progress: () -> untyped

  def initialize: (untyped index, untyped source_requirements, untyped base, untyped gem_version_promoter, untyped additional_base_requirements, untyped platforms) -> void

  def name_for: (untyped dependency) -> untyped

  def name_for_explicit_dependency_source: () -> untyped

  def name_for_locking_dependency_source: () -> untyped

  def relevant_sources_for_vertex: (untyped vertex) -> untyped

  def requirement_satisfied_by?: (untyped requirement, untyped activated, untyped spec) -> untyped

  def search_for: (untyped dependency) -> untyped

  def sort_dependencies: (untyped dependencies, untyped activated, untyped conflicts) -> untyped

  def start: (untyped requirements) -> untyped

  def self.platform_sort_key: (untyped platform) -> untyped

  def self.resolve: (untyped requirements, untyped index, ?untyped source_requirements, ?untyped base, ?untyped gem_version_promoter, ?untyped additional_base_requirements, ?untyped platforms) -> untyped

  def self.sort_platforms: (untyped platforms) -> untyped
end

class Bundler::Resolver::SpecGroup
  include ::Bundler::GemHelpers

  def ==: (untyped other) -> untyped

  def activate_platform!: (untyped platform) -> untyped

  def dependencies_for_activated_platforms: () -> untyped

  def eql?: (untyped other) -> untyped

  def for?: (untyped platform) -> untyped

  def hash: () -> untyped

  def ignores_bundler_dependencies: () -> untyped

  def ignores_bundler_dependencies=: (untyped ignores_bundler_dependencies) -> untyped

  def initialize: (untyped all_specs) -> void

  def name: () -> untyped

  def name=: (untyped name) -> untyped

  def source: () -> untyped

  def source=: (untyped source) -> untyped

  def to_s: () -> untyped

  def to_specs: () -> untyped

  def version: () -> untyped

  def version=: (untyped version) -> untyped
end

module Bundler::RubyDsl
  @ruby_version: untyped

  def ruby: (*::String ruby_version) -> void

  # Support the various file formats found in .ruby-version files.
  #
  #     3.2.2
  #     ruby-3.2.2
  #
  # Also supports .tool-versions files for asdf. Lines not starting with "ruby" are ignored.
  #
  #     ruby 2.5.1 # comment is ignored
  #     ruby   2.5.1# close comment and extra spaces doesn't confuse
  #
  # Intentionally does not support `3.2.1@gemset` since rvm recommends using .ruby-gemset instead
  #
  # Loads the file relative to the dirname of the Gemfile itself.
  def normalize_ruby_file: (::String filename) -> ::String
end

class Bundler::RubyVersion
  def ==: (untyped other) -> untyped

  def diff: (untyped other) -> untyped

  def engine: () -> untyped

  def engine_gem_version: () -> untyped

  def engine_versions: () -> untyped

  def exact?: () -> untyped

  def gem_version: () -> untyped

  def host: () -> untyped

  def initialize: (untyped versions, untyped patchlevel, untyped engine, untyped engine_version) -> void

  def patchlevel: () -> untyped

  def single_version_string: () -> untyped

  def to_gem_version_with_patchlevel: () -> untyped

  def to_s: (?untyped versions) -> untyped

  def versions: () -> untyped

  def versions_string: (untyped versions) -> untyped

  def self.from_string: (untyped string) -> untyped

  def self.system: () -> untyped
end

Bundler::RubyVersion::PATTERN: untyped

class Bundler::RubyVersionMismatch < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::RubygemsIntegration
  # This backports base\_dir which replaces installation path RubyGems 1.8+
  def backport_base_dir: () -> untyped

  def backport_cache_file: () -> untyped

  # This backports the correct segment generation code from RubyGems 1.4+ by
  # monkeypatching it into the method in RubyGems 1.3.6 and 1.3.7.
  def backport_segment_generation: () -> untyped

  def backport_spec_file: () -> untyped

  # This backport fixes the marshaling of @segments.
  def backport_yaml_initialize: () -> untyped

  def bin_path: (untyped gem, untyped bin, untyped ver) -> untyped

  def binstubs_call_gem?: () -> untyped

  def build: (untyped spec, ?untyped skip_validation) -> untyped

  def build_args: () -> untyped

  def build_args=: (untyped args) -> untyped

  def build_gem: (untyped gem_dir, untyped spec) -> untyped

  def clear_paths: () -> untyped

  def config_map: () -> untyped

  def configuration: () -> untyped

  def download_gem: (untyped spec, untyped uri, untyped path) -> untyped

  def ext_lock: () -> untyped

  def fetch_all_remote_specs: (untyped remote) -> untyped

  def fetch_prerelease_specs: () -> untyped

  def fetch_specs: (untyped all, untyped pre) { () -> untyped } -> untyped

  def gem_bindir: () -> untyped

  def gem_cache: () -> untyped

  def gem_dir: () -> untyped

  def gem_from_path: (untyped path, ?untyped policy) -> untyped

  def gem_path: () -> untyped

  def inflate: (untyped obj) -> untyped

  def initialize: () -> void

  def install_with_build_args: (untyped args) -> untyped

  def load_path_insert_index: () -> untyped

  def load_plugin_files: (untyped files) -> untyped

  def load_plugins: () -> untyped

  def loaded_gem_paths: () -> untyped

  def loaded_specs: (untyped name) -> untyped

  def mark_loaded: (untyped spec) -> untyped

  def marshal_spec_dir: () -> untyped

  def method_visibility: (untyped klass, untyped method) -> untyped

  def path: (untyped obj) -> untyped

  def path_separator: () -> untyped

  def platforms: () -> untyped

  def post_reset_hooks: () -> untyped

  def preserve_paths: () -> untyped

  def provides?: (untyped req_str) -> untyped

  def read_binary: (untyped path) -> untyped

  def redefine_method: (untyped klass, untyped method, ?untyped unbound_method) { () -> untyped } -> untyped

  def replace_bin_path: (untyped specs, untyped specs_by_name) -> untyped

  def replace_entrypoints: (untyped specs) -> untyped

  def replace_gem: (untyped specs, untyped specs_by_name) -> untyped

  # Because [`Bundler`](https://docs.ruby-lang.org/en/2.6.0/Bundler.html) has a
  # static view of what specs are available, we don't refresh, so stub it out.
  def replace_refresh: () -> untyped

  def repository_subdirectories: () -> untyped

  def reset: () -> untyped

  def reverse_rubygems_kernel_mixin: () -> untyped

  def ruby_engine: () -> untyped

  def security_policies: () -> untyped

  def security_policy_keys: () -> untyped

  def set_installed_by_version: (untyped spec, ?untyped installed_by_version) -> untyped

  def sources: () -> untyped

  def sources=: (untyped val) -> untyped

  def spec_cache_dirs: () -> untyped

  def spec_default_gem?: (untyped spec) -> untyped

  def spec_extension_dir: (untyped spec) -> untyped

  def spec_from_gem: (untyped path, ?untyped policy) -> untyped

  def spec_matches_for_glob: (untyped spec, untyped glob) -> untyped

  def spec_missing_extensions?: (untyped spec, ?untyped default) -> untyped

  def stub_set_spec: (untyped stub, untyped spec) -> untyped

  def stub_source_index: (untyped specs) -> untyped

  def stubs_provide_full_functionality?: () -> untyped

  def suffix_pattern: () -> untyped

  def ui=: (untyped obj) -> untyped

  def undo_replacements: () -> untyped

  def user_home: () -> untyped

  def validate: (untyped spec) -> untyped

  def version: () -> untyped

  def with_build_args: (untyped args) -> untyped

  def self.provides?: (untyped req_str) -> untyped

  def self.version: () -> untyped
end

Bundler::RubygemsIntegration::EXT_LOCK: untyped

# RubyGems 1.8.0 to 1.8.4
class Bundler::RubygemsIntegration::AlmostModern < Bundler::RubygemsIntegration::Modern
  # RubyGems [>= 1.8.0, < 1.8.5] has a bug that changes
  # [`Gem.dir`](https://docs.ruby-lang.org/en/2.6.0/Gem.html#method-c-dir)
  # whenever you call
  # [`Gem::Installer#install`](https://docs.ruby-lang.org/en/2.6.0/Installer.html#method-i-install)
  # with an :install\_dir set. We have to change it back for our sudo mode to
  # work.
  def preserve_paths: () -> untyped
end

# RubyGems versions 1.3.6 and 1.3.7
class Bundler::RubygemsIntegration::Ancient < Bundler::RubygemsIntegration::Legacy
  def initialize: () -> void
end

# RubyGems 2.0
class Bundler::RubygemsIntegration::Future < Bundler::RubygemsIntegration
  def all_specs: () -> untyped

  def build: (untyped spec, ?untyped skip_validation) -> untyped

  def download_gem: (untyped spec, untyped uri, untyped path) -> untyped

  def fetch_all_remote_specs: (untyped remote) -> untyped

  def fetch_specs: (untyped source, untyped remote, untyped name) -> untyped

  def find_name: (untyped name) -> untyped

  def gem_from_path: (untyped path, ?untyped policy) -> untyped

  def gem_remote_fetcher: () -> untyped

  def install_with_build_args: (untyped args) -> untyped

  def path_separator: () -> untyped

  def repository_subdirectories: () -> untyped

  def stub_rubygems: (untyped specs) -> untyped
end

# RubyGems 1.4 through 1.6
class Bundler::RubygemsIntegration::Legacy < Bundler::RubygemsIntegration
  def all_specs: () -> untyped

  def find_name: (untyped name) -> untyped

  def initialize: () -> void

  def post_reset_hooks: () -> untyped

  def reset: () -> untyped

  def stub_rubygems: (untyped specs) -> untyped

  def validate: (untyped spec) -> untyped
end

# RubyGems 1.8.5-1.8.19
class Bundler::RubygemsIntegration::Modern < Bundler::RubygemsIntegration
  def all_specs: () -> untyped

  def find_name: (untyped name) -> untyped

  def stub_rubygems: (untyped specs) -> untyped
end

# RubyGems 2.1.0
class Bundler::RubygemsIntegration::MoreFuture < Bundler::RubygemsIntegration::Future
  def all_specs: () -> untyped

  # RubyGems-generated binstubs call
  # [`Kernel#gem`](https://docs.ruby-lang.org/en/2.6.0/Kernel.html#method-i-gem)
  def binstubs_call_gem?: () -> untyped

  def find_name: (untyped name) -> untyped

  def initialize: () -> void

  # only 2.5.2+ has all of the stub methods we want to use, and since this is a
  # performance optimization *only*, we'll restrict ourselves to the most recent
  # RG versions instead of all versions that have stubs
  def stubs_provide_full_functionality?: () -> untyped

  def use_gemdeps: (untyped gemfile) -> untyped
end

# RubyGems 1.8.20+
class Bundler::RubygemsIntegration::MoreModern < Bundler::RubygemsIntegration::Modern
  def build: (untyped spec, ?untyped skip_validation) -> untyped
end

# RubyGems 1.7
class Bundler::RubygemsIntegration::Transitional < Bundler::RubygemsIntegration::Legacy
  def stub_rubygems: (untyped specs) -> untyped

  def validate: (untyped spec) -> untyped
end

class Bundler::Runtime
  include ::Bundler::SharedHelpers

  def cache: (?untyped custom_path) -> untyped

  def clean: (?untyped dry_run) -> untyped

  def current_dependencies: () -> untyped

  def dependencies: () -> untyped

  def gems: () -> untyped

  def initialize: (untyped root, untyped definition) -> void

  def lock: (?untyped opts) -> untyped

  def prune_cache: (untyped cache_path) -> untyped

  def requested_specs: () -> untyped

  def require: (*untyped groups) -> untyped

  def requires: () -> untyped

  def setup: (*untyped groups) -> untyped

  def specs: () -> untyped
end

Bundler::Runtime::REQUIRE_ERRORS: untyped

class Bundler::SecurityError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::Settings
  def []: (untyped name) -> untyped

  def all: () -> untyped

  def allow_sudo?: () -> untyped

  def app_cache_path: () -> untyped

  def credentials_for: (untyped uri) -> untyped

  def gem_mirrors: () -> untyped

  def ignore_config?: () -> untyped

  def initialize: (?untyped root) -> void

  def key_for: (untyped key) -> untyped

  def local_overrides: () -> untyped

  def locations: (untyped key) -> untyped

  def mirror_for: (untyped uri) -> untyped

  # for legacy reasons, in
  # [`Bundler`](https://docs.ruby-lang.org/en/2.7.0/Bundler.html) 2, we do not
  # respect :disable\_shared\_gems
  def path: () -> untyped

  def pretty_values_for: (untyped exposed_key) -> untyped

  def set_command_option: (untyped key, untyped value) -> untyped

  def set_command_option_if_given: (untyped key, untyped value) -> untyped

  def set_global: (untyped key, untyped value) -> untyped

  def set_local: (untyped key, untyped value) -> untyped

  def temporary: (untyped update) -> untyped

  def validate!: () -> untyped

  def self.normalize_uri: (untyped uri) -> untyped
end

Bundler::Settings::ARRAY_KEYS: untyped

Bundler::Settings::BOOL_KEYS: untyped

Bundler::Settings::CONFIG_REGEX: untyped

Bundler::Settings::DEFAULT_CONFIG: untyped

Bundler::Settings::NORMALIZE_URI_OPTIONS_PATTERN: untyped

Bundler::Settings::NUMBER_KEYS: untyped

Bundler::Settings::PER_URI_OPTIONS: untyped

class Bundler::Settings::Path < Struct
  def append_ruby_scope: () -> untyped

  def append_ruby_scope=: (untyped _) -> untyped

  def base_path: () -> untyped

  def base_path_relative_to_pwd: () -> untyped

  def default_install_uses_path: () -> untyped

  def default_install_uses_path=: (untyped _) -> untyped

  def explicit_path: () -> untyped

  def explicit_path=: (untyped _) -> untyped

  def path: () -> untyped

  def system_path: () -> untyped

  def system_path=: (untyped _) -> untyped

  def use_system_gems?: () -> untyped

  def validate!: () -> untyped

  def self.[]: (*untyped _) -> untyped

  def self.members: () -> untyped

  def self.new: (*untyped _) -> untyped
end

Bundler::Settings::Path::Elem: untyped

module Bundler::SharedHelpers
  extend ::Bundler::SharedHelpers

  def chdir: (untyped dir) { () -> untyped } -> untyped

  def const_get_safely: (untyped constant_name, untyped namespace) -> untyped

  def default_bundle_dir: () -> untyped

  def default_gemfile: () -> untyped

  def default_lockfile: () -> untyped

  def digest: (untyped name) -> untyped

  def ensure_same_dependencies: (untyped spec, untyped old_deps, untyped new_deps) -> untyped

  def filesystem_access: (untyped path, ?untyped action) { () -> untyped } -> untyped

  def in_bundle?: () -> untyped

  def major_deprecation: (untyped major_version, untyped message) -> untyped

  def md5_available?: () -> untyped

  def pretty_dependency: (untyped dep, ?untyped print_source) -> untyped

  def print_major_deprecations!: () -> untyped

  def pwd: () -> untyped

  def root: () -> untyped

  def set_bundle_environment: () -> untyped

  def set_env: (untyped key, untyped value) -> untyped

  def trap: (untyped signal, ?untyped override) { () -> untyped } -> untyped

  def with_clean_git_env: () { () -> untyped } -> untyped

  def write_to_gemfile: (untyped gemfile_path, untyped contents) -> untyped
end

class Bundler::Source
  def can_lock?: (untyped spec) -> untyped

  def dependency_names: () -> untyped

  def dependency_names=: (untyped dependency_names) -> untyped

  def dependency_names_to_double_check: () -> untyped

  def double_check_for: (*untyped _) -> untyped

  def extension_cache_path: (untyped spec) -> untyped

  def include?: (untyped other) -> untyped

  def inspect: () -> untyped

  def path?: () -> untyped

  def unmet_deps: () -> untyped

  def version_message: (untyped spec) -> untyped
end

class Bundler::Source::Gemspec < Bundler::Source::Path
  def as_path_source: () -> untyped

  def gemspec: () -> untyped

  def initialize: (untyped options) -> void
end

class Bundler::Source::Git < Bundler::Source::Path
  def ==: (untyped other) -> untyped

  def allow_git_ops?: () -> untyped

  def app_cache_dirname: () -> untyped

  def branch: () -> untyped

  def cache: (untyped spec, ?untyped custom_path) -> untyped

  # This is the path which is going to contain a cache of the git repository.
  # When using the same git repository across different projects, this cache
  # will be shared. When using local git repos, this is set to the local repo.
  def cache_path: () -> untyped

  def eql?: (untyped other) -> untyped

  def extension_dir_name: () -> untyped

  def hash: () -> untyped

  def initialize: (untyped options) -> void

  def install: (untyped spec, ?untyped options) -> untyped

  # This is the path which is going to contain a specific checkout of the git
  # repository. When using local git repos, this is set to the local repo.
  #
  # Also aliased as:
  # [`path`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Source/Git.html#method-i-path)
  def install_path: () -> untyped

  def load_spec_files: () -> untyped

  def local_override!: (untyped path) -> untyped

  def name: () -> untyped

  def options: () -> untyped

  # Alias for:
  # [`install_path`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Source/Git.html#method-i-install_path)
  def path: () -> untyped

  def ref: () -> untyped

  def revision: () -> untyped

  def specs: (*untyped _) -> untyped

  def submodules: () -> untyped

  def to_lock: () -> untyped

  def to_s: () -> untyped

  def unlock!: () -> untyped

  def uri: () -> untyped

  def self.from_lock: (untyped options) -> untyped
end

class Bundler::Source::Git::GitCommandError < Bundler::GitError
  def initialize: (untyped command, ?untyped path, ?untyped extra_info) -> void
end

class Bundler::Source::Git::GitNotAllowedError < Bundler::GitError
  def initialize: (untyped command) -> void
end

class Bundler::Source::Git::GitNotInstalledError < Bundler::GitError
  def initialize: () -> void
end

# The
# [`GitProxy`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Source/Git/GitProxy.html)
# is responsible to interact with git repositories. All actions required by the
# [`Git`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Source/Git.html) source is
# encapsulated in this object.
class Bundler::Source::Git::GitProxy
  def branch: () -> untyped

  def checkout: () -> untyped

  def contains?: (untyped commit) -> untyped

  def copy_to: (untyped destination, ?untyped submodules) -> untyped

  def full_version: () -> untyped

  def initialize: (untyped path, untyped uri, untyped ref, ?untyped revision, ?untyped git) -> void

  def path: () -> untyped

  def path=: (untyped path) -> untyped

  def ref: () -> untyped

  def ref=: (untyped ref) -> untyped

  def revision: () -> untyped

  def revision=: (untyped revision) -> untyped

  def uri: () -> untyped

  def uri=: (untyped uri) -> untyped

  def version: () -> untyped
end

class Bundler::Source::Git::MissingGitRevisionError < Bundler::GitError
  def initialize: (untyped ref, untyped repo) -> void
end

class Bundler::Source::Metadata < Bundler::Source
  def ==: (untyped other) -> untyped

  def cached!: () -> untyped

  def eql?: (untyped other) -> untyped

  def hash: () -> untyped

  def install: (untyped spec, ?untyped _opts) -> untyped

  def options: () -> untyped

  def remote!: () -> untyped

  def specs: () -> untyped

  def to_s: () -> untyped

  def version_message: (untyped spec) -> untyped
end

class Bundler::Source::Path < Bundler::Source
  def ==: (untyped other) -> untyped

  def app_cache_dirname: () -> untyped

  def cache: (untyped spec, ?untyped custom_path) -> untyped

  def cached!: () -> untyped

  def eql?: (untyped other) -> untyped

  def expanded_original_path: () -> untyped

  def hash: () -> untyped

  def initialize: (untyped options) -> void

  def install: (untyped spec, ?untyped options) -> untyped

  def local_specs: (*untyped _) -> untyped

  def name: () -> untyped

  def name=: (untyped name) -> untyped

  def options: () -> untyped

  def original_path: () -> untyped

  def path: () -> untyped

  def remote!: () -> untyped

  def root: () -> untyped

  def root_path: () -> untyped

  def specs: () -> untyped

  def to_lock: () -> untyped

  def to_s: () -> untyped

  def version: () -> untyped

  def version=: (untyped version) -> untyped

  def self.from_lock: (untyped options) -> untyped
end

Bundler::Source::Path::DEFAULT_GLOB: untyped

class Bundler::Source::Rubygems < Bundler::Source
  def ==: (untyped other) -> untyped

  def add_remote: (untyped source) -> untyped

  def api_fetchers: () -> untyped

  def builtin_gem?: (untyped spec) -> untyped

  def cache: (untyped spec, ?untyped custom_path) -> untyped

  def cache_path: () -> untyped

  def cached!: () -> untyped

  def cached_built_in_gem: (untyped spec) -> untyped

  def cached_gem: (untyped spec) -> untyped

  def cached_path: (untyped spec) -> untyped

  def cached_specs: () -> untyped

  def caches: () -> untyped

  def can_lock?: (untyped spec) -> untyped

  def credless_remotes: () -> untyped

  def dependency_names_to_double_check: () -> untyped

  def double_check_for: (untyped unmet_dependency_names) -> untyped

  def eql?: (untyped other) -> untyped

  def equivalent_remotes?: (untyped other_remotes) -> untyped

  def fetch_gem: (untyped spec) -> untyped

  def fetch_names: (untyped fetchers, untyped dependency_names, untyped index, untyped override_dupes) -> untyped

  def fetchers: () -> untyped

  def hash: () -> untyped

  def include?: (untyped o) -> untyped

  def initialize: (?untyped options) -> void

  def install: (untyped spec, ?untyped opts) -> untyped

  def installed?: (untyped spec) -> untyped

  def installed_specs: () -> untyped

  def loaded_from: (untyped spec) -> untyped

  # Alias for:
  # [`to_s`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Source/Rubygems.html#method-i-to_s)
  def name: () -> untyped

  def normalize_uri: (untyped uri) -> untyped

  def options: () -> untyped

  def remote!: () -> untyped

  def remote_specs: () -> untyped

  def remotes: () -> untyped

  def remotes_for_spec: (untyped spec) -> untyped

  def remove_auth: (untyped remote) -> untyped

  def replace_remotes: (untyped other_remotes, ?untyped allow_equivalent) -> untyped

  def requires_sudo?: () -> untyped

  def rubygems_dir: () -> untyped

  def specs: () -> untyped

  def suppress_configured_credentials: (untyped remote) -> untyped

  def to_lock: () -> untyped

  # Also aliased as:
  # [`name`](https://docs.ruby-lang.org/en/2.7.0/Bundler/Source/Rubygems.html#method-i-name)
  def to_s: () -> untyped

  def unmet_deps: () -> untyped

  def self.from_lock: (untyped options) -> untyped
end

Bundler::Source::Rubygems::API_REQUEST_LIMIT: untyped

Bundler::Source::Rubygems::API_REQUEST_SIZE: untyped

class Bundler::SourceList
  def add_git_source: (?untyped options) -> untyped

  def add_path_source: (?untyped options) -> untyped

  def add_plugin_source: (untyped source, ?untyped options) -> untyped

  def add_rubygems_remote: (untyped uri) -> untyped

  def add_rubygems_source: (?untyped options) -> untyped

  def all_sources: () -> untyped

  def cached!: () -> untyped

  def default_source: () -> untyped

  def get: (untyped source) -> untyped

  def git_sources: () -> untyped

  def global_rubygems_source: () -> untyped

  def global_rubygems_source=: (untyped uri) -> untyped

  def initialize: () -> void

  def lock_sources: () -> untyped

  def metadata_source: () -> untyped

  def path_sources: () -> untyped

  def plugin_sources: () -> untyped

  def remote!: () -> untyped

  def replace_sources!: (untyped replacement_sources) -> untyped

  def rubygems_primary_remotes: () -> untyped

  def rubygems_remotes: () -> untyped

  def rubygems_sources: () -> untyped
end

class Bundler::SpecSet[out Elem]
  include ::TSort

  include ::Enumerable

  def <<: (*untyped args) { () -> untyped } -> untyped

  def []: (untyped key) -> untyped

  def []=: (untyped key, untyped value) -> untyped

  def add: (*untyped args) { () -> untyped } -> untyped

  def each: (*untyped args) { () -> untyped } -> untyped

  def empty?: (*untyped args) { () -> untyped } -> untyped

  def find_by_name_and_platform: (untyped name, untyped platform) -> untyped

  def for: (untyped dependencies, ?untyped skip, ?untyped check, ?untyped match_current_platform, ?untyped raise_on_missing) -> untyped

  def initialize: (untyped specs) -> void

  def length: (*untyped args) { () -> untyped } -> untyped

  def materialize: (untyped deps, ?untyped missing_specs) -> untyped

  # Materialize for all the specs in the spec set, regardless of what platform
  # they're for This is in contrast to how for does platform filtering (and
  # specifically different from how `materialize` calls `for` only for the
  # current platform) @return [Array<Gem::Specification>]
  def materialized_for_all_platforms: () -> untyped

  def merge: (untyped set) -> untyped

  def remove: (*untyped args) { () -> untyped } -> untyped

  def size: (*untyped args) { () -> untyped } -> untyped

  def sort!: () -> untyped

  def to_a: () -> untyped

  def to_hash: () -> untyped

  def valid_for?: (untyped deps) -> untyped

  def what_required: (untyped spec) -> untyped
end

class Bundler::StubSpecification < Bundler::RemoteSpecification
  def activated: () -> untyped

  def activated=: (untyped activated) -> untyped

  def default_gem: () -> untyped

  def default_gem?: () -> bool

  def full_gem_path: () -> untyped

  def full_require_paths: () -> untyped

  def ignored: () -> untyped

  def ignored=: (untyped ignored) -> untyped

  # This is what we do in bundler/rubygems\_ext
  # [`full_require_paths`](https://docs.ruby-lang.org/en/2.6.0/Bundler/StubSpecification.html#method-i-full_require_paths)
  # is always implemented in >= 2.2.0
  def load_paths: () -> untyped

  def loaded_from: () -> untyped

  def matches_for_glob: (untyped glob) -> untyped

  # This is defined directly to avoid having to load every installed spec
  def missing_extensions?: () -> untyped

  def raw_require_paths: () -> untyped

  def source=: (untyped source) -> untyped

  def stub: () -> untyped

  def stub=: (untyped stub) -> untyped

  def to_yaml: () -> untyped

  def self.from_stub: (untyped stub) -> untyped
end

class Bundler::SudoNotPermittedError < Bundler::BundlerError
  def status_code: () -> untyped
end

class Bundler::TemporaryResourceError < Bundler::PermissionError
  def message: () -> untyped

  def status_code: () -> untyped
end

class Bundler::ThreadCreationError < Bundler::BundlerError
  def status_code: () -> untyped
end

module Bundler::UI
end

class Bundler::UI::RGProxy < Gem::SilentUI
  def initialize: (untyped ui) -> void

  def say: (untyped message) -> untyped
end

class Bundler::UI::Silent
  def add_color: (untyped string, untyped color) -> untyped

  def ask: (untyped message) -> untyped

  def confirm: (untyped message, ?untyped newline) -> untyped

  def debug: (untyped message, ?untyped newline) -> untyped

  def debug?: () -> untyped

  def error: (untyped message, ?untyped newline) -> untyped

  def info: (untyped message, ?untyped newline) -> untyped

  def initialize: () -> void

  def level: (?untyped name) -> untyped

  def level=: (untyped name) -> untyped

  def no?: () -> untyped

  def quiet?: () -> untyped

  def shell=: (untyped shell) -> untyped

  def silence: () -> untyped

  def trace: (untyped message, ?untyped newline, ?untyped force) -> untyped

  def unprinted_warnings: () -> untyped

  def warn: (untyped message, ?untyped newline) -> untyped

  def yes?: (untyped msg) -> untyped
end

module Bundler::URICredentialsFilter
  def self.credential_filtered_string: (untyped str_to_filter, untyped uri) -> untyped

  def self.credential_filtered_uri: (untyped uri_to_anonymize) -> untyped
end

# Internal error, should be rescued
class Bundler::VersionConflict < Bundler::BundlerError
  def conflicts: () -> untyped

  def initialize: (untyped conflicts, ?untyped msg) -> void

  def status_code: () -> untyped
end

class Bundler::VirtualProtocolError < Bundler::BundlerError
  def message: () -> untyped

  def status_code: () -> untyped
end

# A stub yaml serializer that can handle only hashes and strings (as of now).
module Bundler::YAMLSerializer
  def self.dump: (untyped hash) -> untyped

  def self.load: (untyped str) -> untyped
end

Bundler::YAMLSerializer::ARRAY_REGEX: untyped

Bundler::YAMLSerializer::HASH_REGEX: untyped

class Bundler::YamlSyntaxError < Bundler::BundlerError
  def initialize: (untyped orig_exception, untyped msg) -> void

  def orig_exception: () -> untyped

  def status_code: () -> untyped
end

class Bundler::Installer
  def self.ambiguous_gems=: (untyped ambiguous_gems) -> untyped

  def self.ambiguous_gems: () -> untyped

  def post_install_messages: () -> untyped

  def self.install: (untyped root, untyped definition, ?untyped options) -> untyped

  def initialize: (untyped root, untyped definition) -> void

  def run: (untyped options) -> void

  def generate_bundler_executable_stubs: (untyped spec, ?untyped options) -> void

  def generate_standalone_bundler_executable_stubs: (untyped spec, ?untyped options) -> void
end
